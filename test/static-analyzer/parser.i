# 1 "src/parser.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "src/parser.c"
# 1 "src/parser.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdbool.h" 1 3 4
# 4 "src/parser.h" 2

# 1 "src/lexer.h" 1
       


# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 442 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 443 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 444 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 140 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdint.h" 2 3 4
# 5 "src/lexer.h" 2

# 1 "src/buffer.h" 1
       

# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 328 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 3 4
typedef int wchar_t;
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;
# 59 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 144 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 193 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 197 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 244 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;
# 148 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 165 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 245 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 563 "/usr/include/stdlib.h" 3 4
extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 644 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 817 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 837 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 1000 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1010 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1011 "/usr/include/stdlib.h" 2 3 4
# 1020 "/usr/include/stdlib.h" 3 4

# 4 "src/buffer.h" 2




# 7 "src/buffer.h"
typedef struct {
    size_t size;
    size_t pos;
    uint8_t *bytes;
} Buffer;


# 13 "src/buffer.h" 3 4
_Bool 
# 13 "src/buffer.h"
    openAndReadFileToBuffer(char *fileName, Buffer *outBuff);

char peek(Buffer *buffer);
char peekAhead(Buffer *buffer, size_t lookahead);

# 17 "src/buffer.h" 3 4
_Bool 
# 17 "src/buffer.h"
    peekMulti(Buffer *buffer, char *str);
char consume(Buffer *buffer);

# 19 "src/buffer.h" 3 4
_Bool 
# 19 "src/buffer.h"
    consumeIf(Buffer *buffer, char c);

# 20 "src/buffer.h" 3 4
_Bool 
# 20 "src/buffer.h"
    consumeMultiIf(Buffer *buffer, char *str);
void consumeAndCopyOut(Buffer *buffer, size_t numBytes, char **outStr);
# 7 "src/lexer.h" 2
# 1 "src/astring.h" 1
       


# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 3 4

# 149 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 426 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 3 4
} max_align_t;
# 5 "src/astring.h" 2








# 12 "src/astring.h"
typedef struct String {
    uint8_t *str;
    size_t length;
} String;

String astr(char *str);

# 18 "src/astring.h" 3 4
_Bool 
# 18 "src/astring.h"
    astr_cmp(String left, String right);

# 19 "src/astring.h" 3 4
_Bool 
# 19 "src/astring.h"
    astr_ccmp(String left, char *right);
# 8 "src/lexer.h" 2

typedef enum {
    Token_ConstNumeric = 256,
    Token_ConstString,
    Token_ConstChar,

    Token_Ident,
    Token_Whitespace = 260,
    Token_NewLine,
    Token_Comment,

    Token_Ellipsis,
    Token_ShiftRightAssign,
    Token_ShiftLeftAssign,
    Token_AddAssign,
    Token_SubAssign,
    Token_MulAssign,
    Token_DivAssign,
    Token_ModAssign = 270,
    Token_AndAssign,
    Token_XorAssign,
    Token_OrAssign,
    Token_ShiftRightOp,
    Token_ShiftLeftOp,
    Token_IncOp,
    Token_DecOp,
    Token_PtrOp,
    Token_LogAndOp,
    Token_LogOrOp = 280,
    Token_LEqOp,
    Token_GEqOp,
    Token_EqOp,
    Token_NEqOp,

    Token_void,
    Token_char,
    Token_short,
    Token_int,
    Token_long,
    Token_float = 290,
    Token_double,
    Token_signed,
    Token_unsigned,
    Token_bool,
    Token_complex,
    Token_imaginary,

    Token_asm,
    Token_auto,
    Token_break,
    Token_case = 300,
    Token_const,
    Token_continue,
    Token_default,
    Token_do,
    Token_else,
    Token_enum,
    Token_extern,
    Token_for,
    Token_goto,
    Token_if = 310,
    Token_inline,
    Token_register,
    Token_restrict,
    Token_return,
    Token_sizeof,
    Token_static,
    Token_struct,
    Token_switch,
    Token_typedef,
    Token_union = 320,
    Token_volatile,
    Token_while,

    Token_alignas,
    Token_alignof,
    Token_atomic,
    Token_generic,
    Token_noreturn,
    Token_staticAssert,
    Token_threadLocal,
    Token_funcName,
} TokenType;

typedef struct {
    TokenType type;
    uint64_t line;
    uint64_t col;
    char *fileName;
    size_t fileIndex;
    union {
        String ident;
        String whitespace;
        String comment;
        String constString;
        String numeric;
    };
} Token;

typedef struct {
    size_t numTokens;
    size_t pos;
    Token *tokens;
} TokenList;

void tokenList_cleanup(TokenList tokens);

typedef struct {
    char *fileName;
    size_t numLines;
    uint64_t *lineLengths;
} FileInfo;

typedef struct {
    size_t numFiles;
    FileInfo *fileInfo;
} LineInfo;

void addLineLengthInfo(LineInfo *info, char *fileName, uint64_t line, uint64_t length);


# 128 "src/lexer.h" 3 4
_Bool 
# 128 "src/lexer.h"
    lexFile(Buffer buffer, TokenList *outTokens, LineInfo *outInfo);
void printTokens(TokenList tokens);
# 6 "src/parser.h" 2

# 1 "src/linkedList.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 4 "src/linkedList.h" 2

typedef struct SLNode {
    struct SLNode *next;
} SLNode;

void *slNode_getData(SLNode *node);

typedef struct {
    size_t size;
    SLNode *head;
    SLNode *tail;
} SLList;


void sll_append(SLList *list, void *data, size_t size);
# 8 "src/parser.h" 2

typedef struct {
    
# 10 "src/parser.h" 3 4
   _Bool 
# 10 "src/parser.h"
        success;
    char *failMessage;
} ParseRes;

typedef ParseRes (*Parser)(TokenList *tokens, void *data);

typedef enum {
    SimpleParser_List,
    SimpleParser_Optional,
} SimpleParserType;

typedef struct SimpleParser {
    SimpleParserType type;
    union {
        struct {
            Parser listElemParser;
            SLList *listOut;
            size_t listElemSize;
            char *listFailMessage;
        };
        struct {
            void *optionalData;
            Parser optionalParser;
        };
    };
    Parser run;
} SimpleParser;

SimpleParser ListParser(Parser listElemParser, SLList *listOut,
    size_t listElemSize, char *listFailMessage);
SimpleParser OptionalParser(Parser parser, void *data);

struct ConditionalExpr;
struct InitializerList;
struct AssignExpr;
struct TypeName;
struct Expr;
struct CastExpr;
enum TypeQualifier;
struct TypeSpecifier;
struct AbstractDeclarator;
struct Declarator;
struct Statement;
struct CompoundStmt;

typedef enum {
    Designator_Constant,
    Designator_Ident,
} DesignatorType;

typedef struct {
    DesignatorType type;
    union {
        struct ConditionalExpr *constantExpr;
        String ident;
    };
} Designator;

typedef struct {
    SLList list;
} Designation;

typedef enum {
    Initializer_InitializerList,
    Initializer_Assignment,
} InitializerType;

typedef struct {
    InitializerType type;
    union {
        struct InitializerList *initializerList;
        struct AssignExpr *assignmentExpr;
    };
} Initializer;

typedef struct {
    
# 86 "src/parser.h" 3 4
   _Bool 
# 86 "src/parser.h"
        hasDesignation;
    Designation designation;
    Initializer initializer;
} DesignationAndInitializer;

typedef struct InitializerList {
    SLList list;
} InitializerList;

typedef struct {
    
# 96 "src/parser.h" 3 4
   _Bool 
# 96 "src/parser.h"
        isDefault;
    struct TypeName *typeName;
    struct AssignExpr *expr;
} GenericAssociation;

typedef struct {
    struct AssignExpr *expr;
    SLList associations;
} GenericSelection;

typedef enum {
    Constant_Numeric,
    Constant_Character,
} ConstantType;


typedef struct {
    ConstantType type;
    String data;
} ConstantExpr;

typedef enum {
    PrimaryExpr_Ident,
    PrimaryExpr_Constant,
    PrimaryExpr_String,
    PrimaryExpr_FuncName,
    PrimaryExpr_Expr,
    PrimaryExpr_GenericSelection,
} PrimaryExprType;


typedef struct {
    PrimaryExprType type;
    union {
        String ident;
        ConstantExpr constant;
        String string;
        struct Expr *expr;
        GenericSelection genericSelection;
    };
} PrimaryExpr;

typedef struct {
    SLList list;
} ArgExprList;

typedef enum {
    PostfixOp_Index,
    PostfixOp_Call,
    PostfixOp_Dot,
    PostfixOp_Arrow,
    PostfixOp_Inc,
    PostfixOp_Dec,
} PostfixOpType;

typedef struct {
    PostfixOpType type;
    union {
        struct Expr *indexExpr;
        struct {
            
# 156 "src/parser.h" 3 4
           _Bool 
# 156 "src/parser.h"
                callHasEmptyArgs;
            ArgExprList callExprs;
        };
        String dotIdent;
        String arrowIdent;
    };
} PostfixOp;

typedef enum {
    Postfix_Primary,
    Postfix_InitializerList,
} PostfixType;

typedef struct {
    Token *tok;
    PostfixType type;
    union {
        PrimaryExpr primary;
        struct {
            struct TypeName *initializerListType;
            InitializerList initializerList;
        };
    };

    SLList postfixOps;
} PostfixExpr;

typedef enum {
    UnaryPrefix_And,
    UnaryPrefix_Star,
    UnaryPrefix_Plus,
    UnaryPrefix_Minus,
    UnaryPrefix_Tilde,
    UnaryPrefix_Not,
} UnaryExprPrefixType;

typedef enum {
    UnaryExpr_UnaryOp,
    UnaryExpr_Inc,
    UnaryExpr_Dec,
    UnaryExpr_SizeofExpr,
    UnaryExpr_SizeofType,
    UnaryExpr_AlignofType,
    UnaryExpr_Base,
} UnaryExprType;

typedef struct UnaryExpr {
    Token *tok;
    UnaryExprType type;
    union {
        struct {
            UnaryExprPrefixType unaryOpType;
            struct CastExpr *unaryOpCast;
        };
        struct UnaryExpr *incOpExpr;
        struct UnaryExpr *decOpExpr;
        struct UnaryExpr *sizeofExpr;
        struct TypeName *sizeofTypeName;
        struct TypeName *alignofTypeName;
        PostfixExpr baseExpr;
    };
} UnaryExpr;

typedef enum {
    CastExpr_Unary,
    CastExpr_Cast,
} CastExprType;

typedef struct CastExpr {
    Token *tok;
    CastExprType type;
    union {
        UnaryExpr unary;
        struct {
            struct TypeName *castType;
            struct CastExpr *castExpr;
        };
    };
} CastExpr;

typedef enum {
    Multiplicative_Mul,
    Multiplicative_Div,
    Multiplicative_Mod,
} MultiplicativeOp;

typedef struct {
    Token *tok;
    MultiplicativeOp op;
    CastExpr expr;
} MultiplicativePost;

typedef struct {
    Token *tok;
    CastExpr baseExpr;
    SLList postExprs;
} MultiplicativeExpr;

typedef enum {
    Additive_Add,
    Additive_Sub,
} AdditiveOp;

typedef struct {
    Token *tok;
    AdditiveOp op;
    MultiplicativeExpr expr;
} AdditivePost;

typedef struct {
    Token *tok;
    MultiplicativeExpr baseExpr;
    SLList postExprs;
} AdditiveExpr;

typedef enum {
    Shift_Left,
    Shift_Right,
} ShiftOp;

typedef struct {
    Token *tok;
    ShiftOp op;
    AdditiveExpr expr;
} ShiftPost;

typedef struct {
    Token *tok;
    AdditiveExpr baseExpr;
    SLList postExprs;
} ShiftExpr;

typedef enum {
    Relational_Lt,
    Relational_Gt,
    Relational_LEq,
    Relational_GEq,
} RelationalOp;

typedef struct {
    Token *tok;
    RelationalOp op;
    ShiftExpr expr;
} RelationalPost;

typedef struct {
    Token *tok;
    ShiftExpr baseExpr;
    SLList postExprs;
} RelationalExpr;

typedef enum {
    Equality_Eq,
    Equality_NEq,
} EqualityOp;

typedef struct {
    Token *tok;
    EqualityOp op;
    RelationalExpr expr;
} EqualityPost;

typedef struct {
    Token *tok;
    RelationalExpr baseExpr;
    SLList postExprs;
} EqualityExpr;

typedef struct {
    Token *tok;
    SLList list;
} AndExpr;

typedef struct {
    Token *tok;
    SLList list;
} ExclusiveOrExpr;

typedef struct {
    Token *tok;
    SLList list;
} InclusiveOrExpr;

typedef struct {
    Token *tok;
    SLList list;
} LogicalAndExpr;

typedef struct {
    Token *tok;
    SLList list;
} LogicalOrExpr;

typedef struct ConditionalExpr {
    LogicalOrExpr beforeExpr;

    
# 352 "src/parser.h" 3 4
   _Bool 
# 352 "src/parser.h"
        hasConditionalOp;
    struct Expr *ifTrueExpr;
    struct ConditionalExpr *ifFalseExpr;
} ConditionalExpr;

typedef enum {
    Assign_Eq,
    Assign_MulEq,
    Assign_DivEq,
    Assign_ModEq,
    Assign_AddEq,
    Assign_SubEq,
    Assign_ShiftLeftEq,
    Assign_ShiftRightEq,
    Assign_AndEq,
    Assign_XorEq,
    Assign_OrEq,
} AssignOp;

typedef struct {
    UnaryExpr leftExpr;
    AssignOp op;
} AssignPrefix;

typedef struct AssignExpr {
    SLList leftExprs;

    ConditionalExpr rightExpr;
} AssignExpr;



typedef enum {
    InnerExpr_Assign,
    InnerExpr_CompoundStatement,
} InnerExprType;

typedef struct {
    InnerExprType type;
    union {
        AssignExpr assign;
        struct CompoundStmt *compoundStmt;
    };
} InnerExpr;

typedef struct Expr {
    SLList list;
} Expr;

typedef struct {
    struct DeclarationSpecifierList *declarationSpecifiers;
    
# 403 "src/parser.h" 3 4
   _Bool 
# 403 "src/parser.h"
        hasDeclarator;
    struct Declarator *declarator;
    
# 405 "src/parser.h" 3 4
   _Bool 
# 405 "src/parser.h"
        hasAbstractDeclarator;
    struct AbstractDeclarator *abstractDeclarator;
} ParameterDeclaration;

typedef struct {
    SLList paramDecls;
    
# 411 "src/parser.h" 3 4
   _Bool 
# 411 "src/parser.h"
        hasEndingEllipsis;
} ParameterTypeList;

typedef enum {
    PostDirectAbstractDeclarator_Bracket,
    PostDirectAbstractDeclarator_Paren,
} PostDirectAbstractDeclaratorType;

typedef struct {
    PostDirectAbstractDeclaratorType type;
    union {
        struct {
            
# 423 "src/parser.h" 3 4
           _Bool 
# 423 "src/parser.h"
                bracketIsEmpty;
            
# 424 "src/parser.h" 3 4
           _Bool 
# 424 "src/parser.h"
                bracketIsStar;
            
# 425 "src/parser.h" 3 4
           _Bool 
# 425 "src/parser.h"
                bracketHasInitialStatic;

            SLList bracketTypeQualifiers;

            
# 429 "src/parser.h" 3 4
           _Bool 
# 429 "src/parser.h"
                bracketHasMiddleStatic;

            
# 431 "src/parser.h" 3 4
           _Bool 
# 431 "src/parser.h"
                bracketHasAssignmentExpr;
            AssignExpr bracketAssignExpr;
        };
        struct {
            
# 435 "src/parser.h" 3 4
           _Bool 
# 435 "src/parser.h"
                parenIsEmpty;
            ParameterTypeList parenParamList;
        };
    };
} PostDirectAbstractDeclarator;

typedef struct {
    
# 442 "src/parser.h" 3 4
   _Bool 
# 442 "src/parser.h"
        hasAbstractDeclarator;
    struct AbstractDeclarator *abstractDeclarator;
    SLList postDirectAbstractDeclarators;
} DirectAbstractDeclarator;

typedef struct Pointer {
    size_t numPtrs;
    SLList typeQualifiers;
    
# 450 "src/parser.h" 3 4
   _Bool 
# 450 "src/parser.h"
        hasPtr;
    struct Pointer *pointer;
} Pointer;

typedef struct AbstractDeclarator {
    
# 455 "src/parser.h" 3 4
   _Bool 
# 455 "src/parser.h"
        hasPointer;
    Pointer pointer;
    
# 457 "src/parser.h" 3 4
   _Bool 
# 457 "src/parser.h"
        hasDirectAbstractDeclarator;
    DirectAbstractDeclarator directAbstractDeclarator;
} AbstractDeclarator;

typedef struct {
    SLList list;
} IdentifierList;

typedef enum {
    PostDirectDeclaratorParen_Empty,
    PostDirectDeclaratorParen_IdentList,
    PostDirectDeclaratorParen_ParamTypelist,
} PostDirectDeclaratorParenType;

typedef enum {
    PostDirectDeclarator_Paren,
    PostDirectDeclarator_Bracket,
} PostDirectDeclaratorType;

typedef struct {
    PostDirectDeclaratorType type;
    union {
        struct {
            
# 480 "src/parser.h" 3 4
           _Bool 
# 480 "src/parser.h"
                bracketIsEmpty;
            
# 481 "src/parser.h" 3 4
           _Bool 
# 481 "src/parser.h"
                bracketIsStar;

            
# 483 "src/parser.h" 3 4
           _Bool 
# 483 "src/parser.h"
                bracketHasInitialStatic;
            SLList bracketTypeQualifiers;

            
# 486 "src/parser.h" 3 4
           _Bool 
# 486 "src/parser.h"
                bracketHasStarAfterTypeQualifiers;

            
# 488 "src/parser.h" 3 4
           _Bool 
# 488 "src/parser.h"
                bracketHasMiddleStatic;

            
# 490 "src/parser.h" 3 4
           _Bool 
# 490 "src/parser.h"
                bracketHasAssignExpr;
            AssignExpr bracketAssignExpr;
        };
        struct {
            PostDirectDeclaratorParenType parenType;
            union {
                IdentifierList parenIdentList;
                ParameterTypeList parenParamTypeList;
            };
        };
    };
} PostDirectDeclarator;

typedef enum {
    DirectDeclarator_Ident,
    DirectDeclarator_ParenDeclarator,
} DirectDeclaratorType;

typedef struct {
    DirectDeclaratorType type;
    union {
        String ident;
        struct Declarator *declarator;
    };

    SLList postDirectDeclarators;
} DirectDeclarator;


String directDeclarator_getName(DirectDeclarator declarator);

typedef struct Declarator {
    Token *tok;
    
# 523 "src/parser.h" 3 4
   _Bool 
# 523 "src/parser.h"
        hasPointer;
    Pointer pointer;
    DirectDeclarator directDeclarator;
} Declarator;

typedef enum TypeQualifier {
    Qualifier_Const,
    Qualifier_Restrict,
    Qualifier_Volatile,
    Qualifier_Atomic,
} TypeQualifier;

typedef enum {
    SpecifierQualifier_Specifier,
    SpecifierQualifier_Qualifier,
} SpecifierQualifierType;

typedef struct {
    SpecifierQualifierType type;
    union {
        struct TypeSpecifier *typeSpecifier;
        TypeQualifier typeQualifier;
    };
} SpecifierQualifier;

typedef struct {
    SLList list;
} SpecifierQualifierList;

typedef struct TypeName {
    SpecifierQualifierList specifierQualifiers;
    
# 554 "src/parser.h" 3 4
   _Bool 
# 554 "src/parser.h"
        hasAbstractDeclarator;
    AbstractDeclarator abstractDeclarator;
} TypeName;

typedef struct {
    
# 559 "src/parser.h" 3 4
   _Bool 
# 559 "src/parser.h"
        hasDeclarator;
    Declarator declarator;
    
# 561 "src/parser.h" 3 4
   _Bool 
# 561 "src/parser.h"
        hasConstExpr;
    ConditionalExpr constExpr;
} StructDeclarator;

typedef struct {
    SLList list;
} StructDeclaratorList;

typedef struct {
    ConditionalExpr constantExpr;
    String stringLiteral;
} StaticAssertDeclaration;

typedef enum {
    StructDeclaration_StaticAssert,
    StructDeclaration_Normal,
} StructDeclarationType;

typedef struct {
    StructDeclarationType type;
    union {
        StaticAssertDeclaration staticAssert;
        struct {
            SpecifierQualifierList normalSpecifierQualifiers;
            
# 585 "src/parser.h" 3 4
           _Bool 
# 585 "src/parser.h"
                normalHasStructDeclaratorList;
            StructDeclaratorList normalStructDeclaratorList;
        };
    };
} StructDeclaration;

typedef enum {
    StructOrUnion_Struct,
    StructOrUnion_Union,
} StructOrUnion;

typedef struct {
    StructOrUnion structOrUnion;
    
# 598 "src/parser.h" 3 4
   _Bool 
# 598 "src/parser.h"
        hasIdent;
    String ident;
    
# 600 "src/parser.h" 3 4
   _Bool 
# 600 "src/parser.h"
        hasStructDeclarationList;
    SLList structDeclarations;
} StructOrUnionSpecifier;

typedef struct {
    String constantIdent;
    
# 606 "src/parser.h" 3 4
   _Bool 
# 606 "src/parser.h"
        hasConstExpr;
    ConditionalExpr constantExpr;
} Enumerator;

typedef struct {
    SLList list;
} EnumeratorList;

typedef struct {
    
# 615 "src/parser.h" 3 4
   _Bool 
# 615 "src/parser.h"
        hasIdent;
    String ident;
    
# 617 "src/parser.h" 3 4
   _Bool 
# 617 "src/parser.h"
        hasEnumeratorList;
    EnumeratorList enumeratorList;
} EnumSpecifier;

typedef enum {
    TypeSpecifier_Void,
    TypeSpecifier_Char,
    TypeSpecifier_Short,
    TypeSpecifier_Int,
    TypeSpecifier_Long,
    TypeSpecifier_Float,
    TypeSpecifier_Double,
    TypeSpecifier_Signed,
    TypeSpecifier_Unsigned,
    TypeSpecifier_Bool,
    TypeSpecifier_Complex,
    TypeSpecifier_Imaginary,
    TypeSpecifier_AtomicType,
    TypeSpecifier_StructOrUnion,
    TypeSpecifier_Enum,
    TypeSpecifier_TypedefName,
} TypeSpecifierType;

typedef struct TypeSpecifier {
    TypeSpecifierType type;
    union {
        TypeName atomicName;
        StructOrUnionSpecifier structOrUnion;
        EnumSpecifier enumSpecifier;
        String typedefName;
    };
} TypeSpecifier;

typedef enum {
    StorageClass_Typedef,
    StorageClass_Extern,
    StorageClass_Static,
    StorageClass_Thread_Local,
    StorageClass_Auto,
    StorageClass_Register,
} StorageClassSpecifier;

typedef enum {
    FunctionSpecifier_Inline,
    FunctionSpecifier_Noreturn,
} FunctionSpecifier;

typedef enum {
    AlignmentSpecifier_TypeName,
    AlignmentSpecifier_Constant,
} AlignmentSpecifierType;

typedef struct {
    AlignmentSpecifierType type;
    union {
        TypeName typeName;
        ConditionalExpr constant;
    };
} AlignmentSpecifier;

typedef enum {
    DeclarationSpecifier_StorageClass,
    DeclarationSpecifier_Type,
    DeclarationSpecifier_TypeQualifier,
    DeclarationSpecifier_Func,
    DeclarationSpecifier_Alignment,
} DeclarationSpecifierType;

typedef struct {
    DeclarationSpecifierType type;
    union {
        StorageClassSpecifier storageClass;
        TypeSpecifier typeSpecifier;
        TypeQualifier typeQualifier;
        FunctionSpecifier function;
        AlignmentSpecifier alignment;
    };
} DeclarationSpecifier;

typedef struct DeclarationSpecifierList {
    SLList list;
} DeclarationSpecifierList;

typedef struct {
    Declarator decl;
    
# 702 "src/parser.h" 3 4
   _Bool 
# 702 "src/parser.h"
        hasInitializer;
    Initializer initializer;
} InitDeclarator;

typedef struct {
    SLList list;
 } InitDeclaratorList;

typedef enum {
    Declaration_StaticAssert,
    Declaration_Normal,
} DeclarationType;

typedef struct {
    DeclarationType type;
    union {
        StaticAssertDeclaration staticAssert;
        struct {
            DeclarationSpecifierList declSpecifiers;
            
# 721 "src/parser.h" 3 4
           _Bool 
# 721 "src/parser.h"
                hasInitDeclaratorList;
            InitDeclaratorList initDeclaratorList;
        };
    };
} Declaration;

typedef enum {
    LabeledStatement_Ident,
    LabeledStatement_Case,
    LabeledStatement_Default,
} LabeledStatementType;

typedef struct {
    LabeledStatementType type;
    union {
        String ident;
        ConditionalExpr caseConstExpr;
    };
    struct Statement *stmt;
} LabeledStatement;

typedef enum {
    SelectionStatement_If,
    SelectionStatement_Switch,
} SelectionStatementType;

typedef struct {
    SelectionStatementType type;
    union {
        struct {
            Token *ifToken;
            Token *elseToken;

            Expr ifExpr;
            struct Statement *ifTrueStmt;
            
# 756 "src/parser.h" 3 4
           _Bool 
# 756 "src/parser.h"
                ifHasElse;
            struct Statement *ifFalseStmt;
        };
        struct {
            Token *switchToken;

            Expr switchExpr;
            struct Statement *switchStmt;
        };
    };
} SelectionStatement;

typedef struct {
    
# 769 "src/parser.h" 3 4
   _Bool 
# 769 "src/parser.h"
        isEmpty;
    Expr expr;
} ExpressionStatement;

typedef enum {
    IterationStatement_While,
    IterationStatement_DoWhile,
    IterationStatement_For,
} IterationStatementType;

typedef struct {
    IterationStatementType type;
    union {
        struct {
            Token *whileToken;

            Expr whileExpr;
            struct Statement *whileStmt;
        };
        struct {
            Token *doToken;

            struct Statement *doStmt;
            Expr doExpr;
        };
        struct {
            Token *forToken;

            
# 797 "src/parser.h" 3 4
           _Bool 
# 797 "src/parser.h"
                forHasInitialDeclaration;
            Declaration forInitialDeclaration;
            ExpressionStatement forInitialExprStmt;
            ExpressionStatement forInnerExprStmt;
            
# 801 "src/parser.h" 3 4
           _Bool 
# 801 "src/parser.h"
                forHasFinalExpr;
            Expr forFinalExpr;
            struct Statement *forStmt;
        };
    };
} IterationStatement;

typedef enum {
    JumpStatement_Goto,
    JumpStatement_Continue,
    JumpStatement_Break,
    JumpStatement_Return,
} JumpStatementType;

typedef struct {
    JumpStatementType type;
    union {
        String gotoIdent;
        struct {
            
# 820 "src/parser.h" 3 4
           _Bool 
# 820 "src/parser.h"
                returnHasExpr;
            Expr returnExpr;
        };
    };
} JumpStatement;

typedef struct {
    uint8_t tmp;
} AsmStatement;

typedef enum {
    Statement_Labeled,
    Statement_Compound,
    Statement_Expression,
    Statement_Selection,
    Statement_Iteration,
    Statement_Jump,
    Statement_Asm,
} StatementType;

typedef struct Statement {
    StatementType type;
    union {
        LabeledStatement labeled;
        struct CompoundStmt *compound;
        SelectionStatement selection;
        IterationStatement iteration;
        JumpStatement jump;
        ExpressionStatement expression;
        AsmStatement assembly;
    };
} Statement;

typedef enum {
    BlockItem_Declaration,
    BlockItem_Statement,
} BlockItemType;

typedef struct {
    BlockItemType type;
    union {
        Declaration decl;
        Statement stmt;
    };
} BlockItem;

typedef struct {
    SLList list;
} BlockItemList;

typedef struct CompoundStmt {
    Token *openBracket;
    Token *closeBracket;

    
# 874 "src/parser.h" 3 4
   _Bool 
# 874 "src/parser.h"
        isEmpty;
    BlockItemList blockItemList;
} CompoundStmt;

typedef struct {
    Token *startTok;
    Token *endTok;

    DeclarationSpecifierList specifiers;
    Declarator declarator;
    SLList declarations;
    CompoundStmt stmt;
} FuncDef;

typedef enum {
    ExternalDecl_FuncDef,
    ExternalDecl_Decl
} ExternalDeclType;

typedef struct {
    ExternalDeclType type;
    union {
        FuncDef func;
        Declaration decl;
    };
} ExternalDecl;

typedef struct {
    SLList externalDecls;
} TranslationUnit;

void translationUnit_cleanup(TranslationUnit unit);


# 907 "src/parser.h" 3 4
_Bool 
# 907 "src/parser.h"
    parseTokens(TokenList *tokens,
    TranslationUnit *outTranslationUnit);

void printTranslationUnit(TranslationUnit translationUnit);
# 2 "src/parser.c" 2

# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4

# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 90 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 153 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 225 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 302 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 329 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 384 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 409 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 427 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 498 "/usr/include/string.h" 3 4

# 4 "src/parser.c" 2

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4



extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



# 6 "src/parser.c" 2
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4
# 52 "/usr/include/stdio.h" 3 4
typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 173 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 187 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 279 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 292 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 379 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 409 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 434 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 457 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 491 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 516 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 527 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 543 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 609 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 679 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 713 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 737 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 763 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 788 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 806 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 846 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 864 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 879 "/usr/include/stdio.h" 3 4

# 7 "src/parser.c" 2

# 1 "src/logger.h" 1
       


# 3 "src/logger.h"
typedef enum {
    Severity_Debug,
    Severity_Info,
    Severity_Warn,
    Severity_Error,
    Severity_Fatal,
} Severity;

void setSeverity(Severity severity);

void vlog(char *file, int line, Severity severity,
    const char *format, ...);
# 9 "src/parser.c" 2
# 1 "src/array.h" 1
       
# 10 "src/parser.c" 2
# 1 "src/debug.h" 1
       
# 11 "src/parser.c" 2
# 19 "src/parser.c"
ParseRes parseList(TokenList *tokens, void *data)
{
    SimpleParser *parser = data;
    
# 22 "src/parser.c" 3 4
   ((void) sizeof ((
# 22 "src/parser.c"
   parser->type == SimpleParser_List
# 22 "src/parser.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 22 "src/parser.c"
   parser->type == SimpleParser_List
# 22 "src/parser.c" 3 4
   ) ; else __assert_fail (
# 22 "src/parser.c"
   "parser->type == SimpleParser_List"
# 22 "src/parser.c" 3 4
   , "src/parser.c", 22, __extension__ __PRETTY_FUNCTION__); }))
# 22 "src/parser.c"
                                            ;


    ParseRes res = {0};
    do {
        size_t pos = tokens->pos;

        void *elem = calloc(1, parser->listElemSize);
        res = parser->listElemParser(tokens, elem);
        if (!res.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(parser->listOut, elem, parser->listElemSize);

        free(elem);
    } while (res.success);

    if (parser->listOut->size == 0)
        return ((ParseRes){ .success = 
# 42 "src/parser.c" 3 4
              0
# 42 "src/parser.c"
              , .failMessage = parser->listFailMessage });

    return ((ParseRes){ .success = 
# 44 "src/parser.c" 3 4
          1 
# 44 "src/parser.c"
          });
}

ParseRes parseOptional(TokenList *tokens, void *data) {
    SimpleParser *parser = data;
    
# 49 "src/parser.c" 3 4
   ((void) sizeof ((
# 49 "src/parser.c"
   parser->type == SimpleParser_Optional
# 49 "src/parser.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 49 "src/parser.c"
   parser->type == SimpleParser_Optional
# 49 "src/parser.c" 3 4
   ) ; else __assert_fail (
# 49 "src/parser.c"
   "parser->type == SimpleParser_Optional"
# 49 "src/parser.c" 3 4
   , "src/parser.c", 49, __extension__ __PRETTY_FUNCTION__); }))
# 49 "src/parser.c"
                                                ;

    size_t pos = tokens->pos;

    ParseRes res = parser->optionalParser(tokens, parser->optionalData);

    if (!res.success) {
        tokens->pos = pos;
    }

    return ((ParseRes){ .success = 
# 59 "src/parser.c" 3 4
          1 
# 59 "src/parser.c"
          });
}

SimpleParser ListParser(Parser listElemParser, SLList *listOut,
    size_t listElemSize, char *listFailMessage)
{
    SimpleParser res = {0};
    res.type = SimpleParser_List;
    res.listElemParser = listElemParser;
    res.listOut = listOut;
    res.listElemSize = listElemSize;
    res.listFailMessage = listFailMessage;
    res.run = parseList;
    return res;
}

SimpleParser OptionalParser(Parser parser, void *data) {
    SimpleParser res = {0};
    res.type = SimpleParser_Optional;
    res.optionalParser = parser;
    res.optionalData = data;
    res.run = parseOptional;
    return res;
}



static SLList g_typedefTable;


# 88 "src/parser.c" 3 4
_Bool 
# 88 "src/parser.c"
    typedefTable_find(SLList table, String name) {
    for (SLNode *node = table.head; node != 
# 89 "src/parser.c" 3 4
   ((void *)0)
# 89 "src/parser.c"
   ; node = node->next) {
        String *tableName = slNode_getData(node);
        if (astr_cmp(*tableName, name))
            return 
# 92 "src/parser.c" 3 4
                  1
# 92 "src/parser.c"
                      ;
    }

    return 
# 95 "src/parser.c" 3 4
          0
# 95 "src/parser.c"
               ;
}

void typedefTable_add(SLList *table, String name) {
    sll_append(table, &name, sizeof(name));
}







Token peekTok(TokenList *tokens) {
    if (tokens->pos < tokens->numTokens)
        return tokens->tokens[tokens->pos];

    return (Token){ .type = 0 };
}

Token peekAheadTok(TokenList *tokens, size_t lookahead) {
    if (lookahead + tokens->pos >= tokens->numTokens)
        return (Token){ .type = 0 };

    return tokens->tokens[tokens->pos + lookahead];
}

Token consumeTok(TokenList *tokens) {
    Token tok = peekTok(tokens);
    tokens->pos++;
    return tok;
}

void consumeMulti(TokenList *tokens, size_t numToConsume) {
    tokens->pos += numToConsume;
}


# 132 "src/parser.c" 3 4
_Bool 
# 132 "src/parser.c"
    consumeIfTok(TokenList *tokens, TokenType type) {
    if (peekTok(tokens).type == type) {
        tokens->pos++;
        return 
# 135 "src/parser.c" 3 4
              1
# 135 "src/parser.c"
                  ;
    }

    return 
# 138 "src/parser.c" 3 4
          0
# 138 "src/parser.c"
               ;
}


ParseRes parseAssignExpr(TokenList *tokens, AssignExpr *expr);
ParseRes parseConditionalExpr(TokenList *tokens, ConditionalExpr *expr);
ParseRes parseInitializerList(TokenList *tokens, InitializerList *list);
ParseRes parseTypeName(TokenList *tokens, TypeName *typeName);
ParseRes parseExpr(TokenList *tokens, Expr *expr);
ParseRes parseCastExpr(TokenList *tokens, CastExpr *expr);
ParseRes parseTypeSpecifier(TokenList *tokens, TypeSpecifier *type);
ParseRes parseTypeQualifier(TokenList *tokens, TypeQualifier *typeQualifier);
ParseRes parseAbstractDeclarator(TokenList *tokens, AbstractDeclarator *abstractDeclarator);
ParseRes parseCompoundStmt(TokenList *tokens, CompoundStmt *outStmt);
ParseRes parseStatement(TokenList *tokens, Statement *stmt);
ParseRes parseDeclarationSpecifierList(TokenList *tokens, DeclarationSpecifierList *outList);
ParseRes parseDeclarator(TokenList *tokens, Declarator *declarator);


ParseRes parseArgExprList(TokenList *tokens, ArgExprList *argExprList) {
    
# 158 "src/parser.c" 3 4
   _Bool 
# 158 "src/parser.c"
        hasComma = 
# 158 "src/parser.c" 3 4
                   0
# 158 "src/parser.c"
                        ;
    do {
        size_t pos = tokens->pos;

        AssignExpr expr = {0};
        ParseRes res = parseAssignExpr(tokens, &expr);
        if (!res.success) {
            tokens->pos = pos;
            break;
        }

        hasComma = consumeIfTok(tokens, ',');

        sll_append(&argExprList->list, &expr, sizeof(expr));
    } while (hasComma);

    return (ParseRes){ .success = 
# 174 "src/parser.c" 3 4
                                 1 
# 174 "src/parser.c"
                                      };
}

ParseRes parseDesignator(TokenList *tokens, Designator *designator) {
    if (consumeIfTok(tokens, '.')) {
        if (peekTok(tokens).type != Token_Ident) {
            return (ParseRes) {
                .success = 
# 181 "src/parser.c" 3 4
                          0
# 181 "src/parser.c"
                               ,
                .failMessage = "Designator, expected identifier after ."
            };
        }
        designator->type = Designator_Ident;
        designator->ident = consumeTok(tokens).ident;

        return (ParseRes) { .success = 
# 188 "src/parser.c" 3 4
                                      1 
# 188 "src/parser.c"
                                           };
    }
    else if (consumeIfTok(tokens, '[')) {

        ConditionalExpr expr = {0};
        if (!parseConditionalExpr(tokens, &expr).success) {
            return (ParseRes) {
                .success = 
# 195 "src/parser.c" 3 4
                          0
# 195 "src/parser.c"
                               ,
                .failMessage = "Designator, expected conditional expr after ["
            };
        }

        if (!consumeIfTok(tokens, ']')) {
            return (ParseRes) {
                .success = 
# 202 "src/parser.c" 3 4
                          0
# 202 "src/parser.c"
                               ,
                .failMessage = "Designator, expected ] after expr"
            };
        }

        designator->type = Designator_Constant;
        designator->constantExpr = malloc(sizeof(ConditionalExpr));
        memcpy(designator->constantExpr, &expr, sizeof(expr));

        return (ParseRes) { .success = 
# 211 "src/parser.c" 3 4
                                      1 
# 211 "src/parser.c"
                                           };
    }
    else {
        return (ParseRes){
            .success = 
# 215 "src/parser.c" 3 4
                      0
# 215 "src/parser.c"
                           ,
            .failMessage = "Expected . or [ to start a designator"
        };
    }
}

ParseRes parseDesignation(TokenList *tokens, Designation *designation) {
# 237 "src/parser.c"
    SimpleParser list = ListParser((Parser)parseDesignator, &(designation->list),
        sizeof(Designator), "Failed to find designator list in designation");
    list.run(tokens, &list);

    if (!consumeIfTok(tokens, '=')) {
        return (ParseRes){
            .success = 
# 243 "src/parser.c" 3 4
                      0
# 243 "src/parser.c"
                           ,
            .failMessage = "Didn't find = after designation"
        };
    }

    return (ParseRes){ .success = 
# 248 "src/parser.c" 3 4
                                 1 
# 248 "src/parser.c"
                                      };
}

ParseRes parseInitializer(TokenList *tokens, Initializer *initializer) {
    if (consumeIfTok(tokens, '{')) {
        InitializerList list = {0};
        ParseRes res = parseInitializerList(tokens, &list);
        if (!res.success) {
            return res;
        }


        consumeIfTok(tokens, ',');

        if (!consumeIfTok(tokens, '}')) {
            return (ParseRes) {
                .success = 
# 264 "src/parser.c" 3 4
                          0
# 264 "src/parser.c"
                               ,
                .failMessage = "Expected } after initializer list"
            };
        }

        initializer->type = Initializer_InitializerList;
        initializer->initializerList = malloc(sizeof(list));
        memcpy(initializer->initializerList, &list, sizeof(list));

        return (ParseRes){ .success = 
# 273 "src/parser.c" 3 4
                                     1 
# 273 "src/parser.c"
                                          };
    }


    AssignExpr expr = {0};
    ParseRes assignRes = parseAssignExpr(tokens, &expr);
    if (!assignRes.success)
        return assignRes;

    initializer->type = Initializer_Assignment;
    initializer->assignmentExpr = malloc(sizeof(expr));
    memcpy(initializer->assignmentExpr, &expr, sizeof(expr));

    return (ParseRes){ .success = 
# 286 "src/parser.c" 3 4
                                 1 
# 286 "src/parser.c"
                                      };
}

ParseRes parseInitializerList(TokenList *tokens, InitializerList *list) {

    
# 291 "src/parser.c" 3 4
   _Bool 
# 291 "src/parser.c"
        hasComma = 
# 291 "src/parser.c" 3 4
                   0
# 291 "src/parser.c"
                        ;
    
# 292 "src/parser.c" 3 4
   _Bool 
# 292 "src/parser.c"
        isAtEnd = 
# 292 "src/parser.c" 3 4
                  0
# 292 "src/parser.c"
                       ;
    do {
        size_t beforePos = tokens->pos;


        Designation designation = {0};
        
# 298 "src/parser.c" 3 4
       _Bool 
# 298 "src/parser.c"
            hasDesignation = 
# 298 "src/parser.c" 3 4
                             1
# 298 "src/parser.c"
                                 ;
        if (!parseDesignation(tokens, &designation).success) {
            tokens->pos = beforePos;
            hasDesignation = 
# 301 "src/parser.c" 3 4
                            0
# 301 "src/parser.c"
                                 ;
        }


        Initializer initializer = {0};
        if (!parseInitializer(tokens, &initializer).success) {
            return (ParseRes) {
                .success = 
# 308 "src/parser.c" 3 4
                          0
# 308 "src/parser.c"
                               ,
                .failMessage = "Failed to parse an initializer"
            };
        }

        DesignationAndInitializer wholeInitializer = {
            .hasDesignation = hasDesignation,
            .designation = designation,
            .initializer = initializer
        };

        sll_append(&(list->list), &wholeInitializer, sizeof(wholeInitializer));


        hasComma = consumeIfTok(tokens, ',');

        isAtEnd = peekTok(tokens).type == '}';

    } while (!isAtEnd && hasComma);

    return (ParseRes){ .success = 
# 328 "src/parser.c" 3 4
                                 1 
# 328 "src/parser.c"
                                      };
}

ParseRes parseGenericAssociation(TokenList *tokens, GenericAssociation *association) {
    if (consumeIfTok(tokens, Token_default)) {
        if (!consumeIfTok(tokens, ':')) {
            return (ParseRes) {
                .success = 
# 335 "src/parser.c" 3 4
                          0
# 335 "src/parser.c"
                               ,
                .failMessage = "Didn't find : after Default in generic association"
            };
        }

        AssignExpr expr = {0};
        ParseRes assignRes = parseAssignExpr(tokens, &expr);
        if (!assignRes.success)
            return assignRes;

        association->isDefault = 
# 345 "src/parser.c" 3 4
                                1
# 345 "src/parser.c"
                                    ;
        association->expr = malloc(sizeof(expr));
        memcpy(association->expr, &expr, sizeof(expr));
        return (ParseRes){ .success = 
# 348 "src/parser.c" 3 4
                                     1 
# 348 "src/parser.c"
                                          };
    }

    TypeName typeName = {0};
    ParseRes typeNameRes = parseTypeName(tokens, &typeName);
    if (!typeNameRes.success)
        return typeNameRes;

    if (!consumeIfTok(tokens, ':')) {
        return (ParseRes) {
            .success = 
# 358 "src/parser.c" 3 4
                      0
# 358 "src/parser.c"
                           ,
            .failMessage = "Didn't find : after type name in generic association"
        };
    }

    AssignExpr expr = {0};
    ParseRes assignRes = parseAssignExpr(tokens, &expr);
    if (!assignRes.success)
        return assignRes;

    association->isDefault = 
# 368 "src/parser.c" 3 4
                            0
# 368 "src/parser.c"
                                 ;
    association->typeName = malloc(sizeof(typeName));
    memcpy(association->typeName, &typeName, sizeof(typeName));
    association->expr = malloc(sizeof(expr));
    memcpy(association->expr, &expr, sizeof(expr));
    return (ParseRes){ .success = 
# 373 "src/parser.c" 3 4
                                 1 
# 373 "src/parser.c"
                                      };
}

ParseRes parseGenericSelection(TokenList *tokens, GenericSelection *generic) {
    if (!consumeIfTok(tokens, Token_generic)) {
        return (ParseRes) {
            .success = 
# 379 "src/parser.c" 3 4
                      0
# 379 "src/parser.c"
                           ,
            .failMessage = "Didn't find _Generic in front of generic selection"
        };
    }

    if (!consumeIfTok(tokens, '(')) {
        return (ParseRes) {
            .success = 
# 386 "src/parser.c" 3 4
                      0
# 386 "src/parser.c"
                           ,
            .failMessage = "Didn't find ( after _Generic keyword"
        };
    }

    AssignExpr assign = {0};
    ParseRes assignRes = parseAssignExpr(tokens, &assign);
    if (!assignRes.success)
        return assignRes;

    if (!consumeIfTok(tokens, ',')) {
        return (ParseRes) {
            .success = 
# 398 "src/parser.c" 3 4
                      0
# 398 "src/parser.c"
                           ,
            .failMessage = "Didn't find , after assign expr in generic selection"
        };
    }

    generic->expr = malloc(sizeof(assign));
    memcpy(generic->expr, &assign, sizeof(assign));

    
# 406 "src/parser.c" 3 4
   _Bool 
# 406 "src/parser.c"
        hasComma = 
# 406 "src/parser.c" 3 4
                   0
# 406 "src/parser.c"
                        ;
    do {

        GenericAssociation association = {0};
        ParseRes res = parseGenericAssociation(tokens, &association);
        if (!res.success) {
            return res;
        }

        sll_append(&(generic->associations), &association, sizeof(association));


        hasComma = consumeIfTok(tokens, ',');
    } while(hasComma);

    if (!consumeIfTok(tokens, ')')) {
        return (ParseRes) {
            .success = 
# 423 "src/parser.c" 3 4
                      0
# 423 "src/parser.c"
                           ,
            .failMessage = "Didn't find ) after generic association list"
        };
    }

    return (ParseRes) { .success = 
# 428 "src/parser.c" 3 4
                                  1 
# 428 "src/parser.c"
                                       };
}

ParseRes parsePrimaryExpr(TokenList *tokens, PrimaryExpr *primary) {
    if (peekTok(tokens).type == Token_ConstString) {


        Token tok = {0};
        while (peekTok(tokens).type == Token_ConstString)
            tok = consumeTok(tokens);

        primary->type = PrimaryExpr_String;
        primary->string = tok.constString;
        return (ParseRes){ .success = 
# 441 "src/parser.c" 3 4
                                     1 
# 441 "src/parser.c"
                                          };
    }
    else if (peekTok(tokens).type == '(') {
        consumeTok(tokens);

        Expr expr = {0};
        ParseRes res = parseExpr(tokens, &expr);
        if (!res.success)
            return res;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 453 "src/parser.c" 3 4
                          0
# 453 "src/parser.c"
                               ,
                .failMessage = "Expected ) after ( expr in primary expr"
            };
        }

        primary->type = PrimaryExpr_Expr;
        primary->expr = malloc(sizeof(expr));
        memcpy(primary->expr, &expr, sizeof(expr));
        return (ParseRes){ .success = 
# 461 "src/parser.c" 3 4
                                     1 
# 461 "src/parser.c"
                                          };
    }
    else if (peekTok(tokens).type == Token_ConstNumeric) {
        Token tok = consumeTok(tokens);

        primary->type = PrimaryExpr_Constant;
        primary->constant.type = Constant_Numeric;
        primary->constant.data = tok.numeric;
        return (ParseRes){ .success = 
# 469 "src/parser.c" 3 4
                                     1 
# 469 "src/parser.c"
                                          };
    }
    else if (peekTok(tokens).type == Token_funcName) {
        consumeTok(tokens);

        primary->type = PrimaryExpr_FuncName;
        return (ParseRes){ .success = 
# 475 "src/parser.c" 3 4
                                     1 
# 475 "src/parser.c"
                                          };
    }
    else if (peekTok(tokens).type == Token_Ident) {
        Token tok = consumeTok(tokens);

        primary->type = PrimaryExpr_Ident;
        primary->ident = tok.ident;
        return (ParseRes){ .success = 
# 482 "src/parser.c" 3 4
                                     1 
# 482 "src/parser.c"
                                          };
    }
    else if (peekTok(tokens).type == Token_generic) {
        GenericSelection generic = {0};
        ParseRes genericRes = parseGenericSelection(tokens, &generic);

        if (!genericRes.success) {
            return genericRes;
        }

        primary->type = PrimaryExpr_GenericSelection;
        primary->genericSelection = generic;
        return (ParseRes){ .success = 
# 494 "src/parser.c" 3 4
                                     1 
# 494 "src/parser.c"
                                          };
    }

    return (ParseRes) {
        .success = 
# 498 "src/parser.c" 3 4
                  0
# 498 "src/parser.c"
                       ,
        .failMessage = "Failed to parse any primary exprs"
    };
}

ParseRes parsePostfixOp(TokenList *tokens, PostfixOp *op) {
    if (consumeIfTok(tokens, '[')) {
        Expr expr = {0};
        ParseRes res = parseExpr(tokens, &expr);
        if (!res.success)
            return res;

        if (!consumeIfTok(tokens, ']')) {
            return (ParseRes) {
                .success = 
# 512 "src/parser.c" 3 4
                          0
# 512 "src/parser.c"
                               ,
                .failMessage = "Expexted ] after indexing postfix"
            };
        }

        op->type = PostfixOp_Index;
        op->indexExpr = malloc(sizeof(expr));
        memcpy(op->indexExpr, &expr, sizeof(expr));
        return (ParseRes){ .success = 
# 520 "src/parser.c" 3 4
                                     1 
# 520 "src/parser.c"
                                          };
    }
    if (consumeIfTok(tokens, '(')) {
        op->type = PostfixOp_Call;
        if (consumeIfTok(tokens, ')')) {
            op->callHasEmptyArgs = 
# 525 "src/parser.c" 3 4
                                  1
# 525 "src/parser.c"
                                      ;
            return (ParseRes){ .success = 
# 526 "src/parser.c" 3 4
                                         1 
# 526 "src/parser.c"
                                              };
        }

        ArgExprList argExprList = {0};
        ParseRes exprRes = parseArgExprList(tokens, &argExprList);
        if (!exprRes.success)
            return exprRes;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 536 "src/parser.c" 3 4
                          0
# 536 "src/parser.c"
                               ,
                .failMessage = "Expected ) after call arg expr list"
            };
        }

        op->callExprs = argExprList;
        return (ParseRes){ .success = 
# 542 "src/parser.c" 3 4
                                     1 
# 542 "src/parser.c"
                                          };
    }
    if (consumeIfTok(tokens, '.')) {
        if (peekTok(tokens).type != Token_Ident) {
            return (ParseRes) {
                .success = 
# 547 "src/parser.c" 3 4
                          0
# 547 "src/parser.c"
                               ,
                .failMessage = "Expected ident after . access op"
            };
        }

        Token ident = consumeTok(tokens);

        op->type = PostfixOp_Dot;
        op->dotIdent = ident.ident;
        return (ParseRes){ .success = 
# 556 "src/parser.c" 3 4
                                     1 
# 556 "src/parser.c"
                                          };
    }
    if (consumeIfTok(tokens, Token_PtrOp)) {
        if (peekTok(tokens).type != Token_Ident) {
            return (ParseRes) {
                .success = 
# 561 "src/parser.c" 3 4
                          0
# 561 "src/parser.c"
                               ,
                .failMessage = "Expected ident after -> access op"
            };
        }

        Token ident = consumeTok(tokens);

        op->type = PostfixOp_Arrow;
        op->arrowIdent = ident.ident;
        return (ParseRes){ .success = 
# 570 "src/parser.c" 3 4
                                     1 
# 570 "src/parser.c"
                                          };
    }
    if (consumeIfTok(tokens, Token_IncOp)) {
        op->type = PostfixOp_Inc;
        return (ParseRes){ .success = 
# 574 "src/parser.c" 3 4
                                     1 
# 574 "src/parser.c"
                                          };
    }
    if (consumeIfTok(tokens, Token_DecOp)) {
        op->type = PostfixOp_Dec;
        return (ParseRes){ .success = 
# 578 "src/parser.c" 3 4
                                     1 
# 578 "src/parser.c"
                                          };
    }

    return (ParseRes) {
        .success = 
# 582 "src/parser.c" 3 4
                  0
# 582 "src/parser.c"
                       ,
        .failMessage = "Didn't find a postfix op"
    };
}

ParseRes parsePostfixExpr(TokenList *tokens, PostfixExpr *postfixExpr) {
    postfixExpr->tok = tokens->tokens + tokens->pos;


    size_t preInitializeListPos = tokens->pos;



    if (!consumeIfTok(tokens, '('))
        goto PostfixExpr_AfterPostfix;

    TypeName typeName = {0};
    if (!(parseTypeName(tokens, &typeName).success))
        goto PostfixExpr_AfterPostfix;

    if (!consumeIfTok(tokens, ')'))
        goto PostfixExpr_AfterPostfix;

    if (!consumeIfTok(tokens, '{'))
        goto PostfixExpr_AfterPostfix;

    InitializerList list = {0};
    if (!(parseInitializerList(tokens, &list).success))
        goto PostfixExpr_AfterPostfix;


    consumeIfTok(tokens, ',');

    if (!consumeIfTok(tokens, '}'))
        goto PostfixExpr_AfterPostfix;


    postfixExpr->type = Postfix_InitializerList;
    postfixExpr->initializerListType = malloc(sizeof(typeName));
    memcpy(postfixExpr->initializerListType, &typeName, sizeof(typeName));
    postfixExpr->initializerList = list;

    goto PostfixExpr_AfterPrimaryExpr;

PostfixExpr_AfterPostfix:
    tokens->pos = preInitializeListPos;


    PrimaryExpr primary = {0};
    ParseRes primaryRes = parsePrimaryExpr(tokens, &primary);
    if (!primaryRes.success) {
        return primaryRes;
    }

    postfixExpr->type = Postfix_Primary;
    postfixExpr->primary = primary;

PostfixExpr_AfterPrimaryExpr:
    ;

    ParseRes res = {0};
    do {
        size_t postfixPos = tokens->pos;

        PostfixOp op = {0};
        res = parsePostfixOp(tokens, &op);
        if (!res.success) {
            tokens->pos = postfixPos;
            break;
        }

        sll_append(&(postfixExpr->postfixOps), &op, sizeof(op));
    } while (res.success);

    return (ParseRes){ .success = 
# 656 "src/parser.c" 3 4
                                 1 
# 656 "src/parser.c"
                                      };
}

ParseRes parseUnaryExprPrefix(TokenList *tokens, UnaryExprPrefixType *type) {
    if (consumeIfTok(tokens, '&')) {
        *type = UnaryPrefix_And;
        return (ParseRes){ .success = 
# 662 "src/parser.c" 3 4
                                     1 
# 662 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, '*')) {
        *type = UnaryPrefix_Star;
        return (ParseRes){ .success = 
# 666 "src/parser.c" 3 4
                                     1 
# 666 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, '+')) {
        *type = UnaryPrefix_Plus;
        return (ParseRes){ .success = 
# 670 "src/parser.c" 3 4
                                     1 
# 670 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, '-')) {
        *type = UnaryPrefix_Minus;
        return (ParseRes){ .success = 
# 674 "src/parser.c" 3 4
                                     1 
# 674 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, '~')) {
        *type = UnaryPrefix_Tilde;
        return (ParseRes){ .success = 
# 678 "src/parser.c" 3 4
                                     1 
# 678 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, '!')) {
        *type = UnaryPrefix_Not;
        return (ParseRes){ .success = 
# 682 "src/parser.c" 3 4
                                     1 
# 682 "src/parser.c"
                                          };
    }

    return (ParseRes){
        .success = 
# 686 "src/parser.c" 3 4
                  0
# 686 "src/parser.c"
                       ,
        .failMessage = "Expected to find a unary prefix op"
    };
}

ParseRes parseUnaryExpr(TokenList *tokens, UnaryExpr *unaryExpr) {
    unaryExpr->tok = tokens->tokens + tokens->pos;

    size_t pos = tokens->pos;


    {
        UnaryExprPrefixType prefixType = {0};
        if (!parseUnaryExprPrefix(tokens, &prefixType).success)
            goto ParseUnaryExpr_PostPrefix;


        CastExpr cast = {0};
        if (!parseCastExpr(tokens, &cast).success)
            goto ParseUnaryExpr_PostPrefix;

        unaryExpr->type = UnaryExpr_UnaryOp;
        unaryExpr->unaryOpType = prefixType;
        unaryExpr->unaryOpCast = malloc(sizeof(cast));
        memcpy(unaryExpr->unaryOpCast, &cast, sizeof(cast));
        return (ParseRes){ .success = 
# 711 "src/parser.c" 3 4
                                     1 
# 711 "src/parser.c"
                                          };
    }

ParseUnaryExpr_PostPrefix:

    tokens->pos = pos;


    {
        if (peekTok(tokens).type != Token_IncOp &&
            peekTok(tokens).type != Token_DecOp &&
            peekTok(tokens).type != Token_sizeof)
        {
            goto ParseUnaryExpr_PostIncDecSizeofExpr;
        }

        Token tok = consumeTok(tokens);

        UnaryExpr innerExpr = {0};
        if (!parseUnaryExpr(tokens, &innerExpr).success)
            goto ParseUnaryExpr_PostIncDecSizeofExpr;

        UnaryExpr *innerAllocated = malloc(sizeof(innerExpr));
        memcpy(innerAllocated, &innerExpr, sizeof(innerExpr));
        if (tok.type == Token_IncOp) {
            unaryExpr->type = UnaryExpr_Inc;
            unaryExpr->incOpExpr = innerAllocated;
        }
        else if (tok.type == Token_DecOp) {
            unaryExpr->type = UnaryExpr_Dec;
            unaryExpr->decOpExpr = innerAllocated;
        }
        else {
            unaryExpr->type = UnaryExpr_SizeofExpr;
            unaryExpr->sizeofExpr = innerAllocated;
        }

        return (ParseRes){ .success = 
# 748 "src/parser.c" 3 4
                                     1 
# 748 "src/parser.c"
                                          };
    }

ParseUnaryExpr_PostIncDecSizeofExpr:

    tokens->pos = pos;


    {
        if (!consumeIfTok(tokens, Token_sizeof))
            goto ParseUnaryExpr_PostSizeofTypename;

        if (!consumeIfTok(tokens, '('))
            goto ParseUnaryExpr_PostSizeofTypename;

        TypeName typeName = {0};
        if (!parseTypeName(tokens, &typeName).success)
            goto ParseUnaryExpr_PostSizeofTypename;

        if (!consumeIfTok(tokens, ')'))
            goto ParseUnaryExpr_PostSizeofTypename;

        unaryExpr->type = UnaryExpr_SizeofType;
        unaryExpr->sizeofTypeName = malloc(sizeof(typeName));
        memcpy(unaryExpr->sizeofExpr, &typeName, sizeof(typeName));

        return (ParseRes){ .success = 
# 774 "src/parser.c" 3 4
                                     1 
# 774 "src/parser.c"
                                          };
    }

ParseUnaryExpr_PostSizeofTypename:

    tokens->pos = pos;


    {
        if (!consumeIfTok(tokens, Token_alignof))
            goto ParseUnaryExpr_PostAlignofTypename;

        if (!consumeIfTok(tokens, '('))
            goto ParseUnaryExpr_PostAlignofTypename;

        TypeName typeName = {0};
        if (!parseTypeName(tokens, &typeName).success)
            goto ParseUnaryExpr_PostAlignofTypename;

        if (!consumeIfTok(tokens, ')'))
            goto ParseUnaryExpr_PostAlignofTypename;

        unaryExpr->type = UnaryExpr_AlignofType;
        unaryExpr->alignofTypeName = malloc(sizeof(typeName));
        memcpy(unaryExpr->alignofTypeName, &typeName, sizeof(typeName));

        return (ParseRes){ .success = 
# 800 "src/parser.c" 3 4
                                     1 
# 800 "src/parser.c"
                                          };
    }

ParseUnaryExpr_PostAlignofTypename:

    tokens->pos = pos;


    PostfixExpr postfix = {0};
    ParseRes postfixRes = parsePostfixExpr(tokens, &postfix);
    if (!postfixRes.success)
        return postfixRes;

    unaryExpr->type = UnaryExpr_Base;
    unaryExpr->baseExpr = postfix;

    return (ParseRes){ .success = 
# 816 "src/parser.c" 3 4
                                 1 
# 816 "src/parser.c"
                                      };
}

ParseRes parseCastExpr(TokenList *tokens, CastExpr *cast) {
    cast->tok = tokens->tokens + tokens->pos;


    size_t castPos = tokens->pos;

    if (!consumeIfTok(tokens, '('))
        goto Cast_NoCast;

    TypeName typeName = {0};
    ParseRes typeNameRes = parseTypeName(tokens, &typeName);
    if (!typeNameRes.success)
        goto Cast_NoCast;

    if (!consumeIfTok(tokens, ')'))
        goto Cast_NoCast;

    CastExpr newCast = {0};
    ParseRes castRes = parseCastExpr(tokens, &newCast);
    if (!castRes.success)
        goto Cast_NoCast;

    cast->type = CastExpr_Cast;
    cast->castType = malloc(sizeof(typeName));
    memcpy(cast->castType, &typeName, sizeof(typeName));
    cast->castExpr = malloc(sizeof(CastExpr));
    memcpy(cast->castExpr, &newCast, sizeof(newCast));

    return (ParseRes){ .success = 
# 847 "src/parser.c" 3 4
                                 1 
# 847 "src/parser.c"
                                      };

Cast_NoCast:
    tokens->pos = castPos;


    UnaryExpr unary = {0};
    ParseRes unaryRes = parseUnaryExpr(tokens, &unary);
    if (!unaryRes.success)
        return unaryRes;

    cast->type = CastExpr_Unary;
    cast->unary = unary;

    return (ParseRes){ .success = 
# 861 "src/parser.c" 3 4
                                 1 
# 861 "src/parser.c"
                                      };
}

ParseRes parseMultiplicativeExpr(TokenList *tokens, MultiplicativeExpr *multiplicativeExpr) {
    multiplicativeExpr->tok = tokens->tokens + tokens->pos;

    CastExpr castExpr = {0};
    ParseRes res = parseCastExpr(tokens, &castExpr);
    if (!res.success) {

        return res;
    }

    multiplicativeExpr->baseExpr = castExpr;

    while (peekTok(tokens).type == '*' ||
        peekTok(tokens).type == '/' ||
        peekTok(tokens).type == '%')
    {
        Token *tok = tokens->tokens + tokens->pos;

        TokenType type = consumeTok(tokens).type;
        MultiplicativeOp op = type == '*' ? Multiplicative_Mul :
            type == '/' ? Multiplicative_Div :
            Multiplicative_Mod;

        CastExpr cast = {0};
        ParseRes res = parseCastExpr(tokens, &cast);
        if (!res.success) {

            return res;
        }

        MultiplicativePost post = {
            .tok = tok,
            .op = op,
            .expr = cast
        };

        sll_append(&(multiplicativeExpr->postExprs), &post, sizeof(post));
    }

    return (ParseRes){ .success = 
# 903 "src/parser.c" 3 4
                                 1 
# 903 "src/parser.c"
                                      };
}

ParseRes parseAdditiveExpr(TokenList *tokens, AdditiveExpr *additiveExpr) {
    additiveExpr->tok = tokens->tokens + tokens->pos;

    MultiplicativeExpr multiplicativeExpr = {0};
    ParseRes res = parseMultiplicativeExpr(tokens, &multiplicativeExpr);
    if (!res.success) {

        return res;
    }

    additiveExpr->baseExpr = multiplicativeExpr;

    while (peekTok(tokens).type == '+' ||
        peekTok(tokens).type == '-')
    {
        Token *tok = tokens->tokens + tokens->pos;

        TokenType type = consumeTok(tokens).type;
        AdditiveOp op = type == '+' ? Additive_Add : Additive_Sub;

        MultiplicativeExpr multiplicative = {0};
        ParseRes res = parseMultiplicativeExpr(tokens, &multiplicative);
        if (!res.success) {

            return res;
        }

        AdditivePost post = {
            .tok = tok,
            .op = op,
            .expr = multiplicative
        };

        sll_append(&(additiveExpr->postExprs), &post, sizeof(post));
    }

    return (ParseRes){ .success = 
# 942 "src/parser.c" 3 4
                                 1 
# 942 "src/parser.c"
                                      };
}

ParseRes parseShiftExpr(TokenList *tokens, ShiftExpr *shiftExpr) {
    shiftExpr->tok = tokens->tokens + tokens->pos;

    AdditiveExpr additiveExpr = {0};
    ParseRes res = parseAdditiveExpr(tokens, &additiveExpr);
    if (!res.success) {

        return res;
    }

    shiftExpr->baseExpr = additiveExpr;

    while (peekTok(tokens).type == Token_ShiftLeftOp ||
        peekTok(tokens).type == Token_ShiftRightOp)
    {
        Token *tok = tokens->tokens + tokens->pos;

        TokenType type = consumeTok(tokens).type;
        ShiftOp op = type == Token_ShiftLeftOp ? Shift_Left : Shift_Right;

        AdditiveExpr additive = {0};
        ParseRes res = parseAdditiveExpr(tokens, &additive);
        if (!res.success) {

            return res;
        }

        ShiftPost post = {
            .tok = tok,
            .op = op,
            .expr = additive
        };

        sll_append(&(shiftExpr->postExprs), &post, sizeof(post));
    }

    return (ParseRes){ .success = 
# 981 "src/parser.c" 3 4
                                 1 
# 981 "src/parser.c"
                                      };
}

ParseRes parseRelationalExpr(TokenList *tokens, RelationalExpr *relExpr) {
    relExpr->tok = tokens->tokens + tokens->pos;

    ShiftExpr shiftExpr = {0};
    ParseRes res = parseShiftExpr(tokens, &shiftExpr);
    if (!res.success) {

        return res;
    }

    relExpr->baseExpr = shiftExpr;

    while (peekTok(tokens).type == '<' ||
        peekTok(tokens).type == '>' ||
        peekTok(tokens).type == Token_LEqOp ||
        peekTok(tokens).type == Token_GEqOp)
    {
        Token *tok = tokens->tokens + tokens->pos;

        TokenType type = consumeTok(tokens).type;
        RelationalOp op = type == '<' ? Relational_Lt :
            type == '>' ? Relational_Gt :
            type == Token_LEqOp ? Relational_LEq :
            Relational_GEq;

        ShiftExpr shift = {0};
        ParseRes res = parseShiftExpr(tokens, &shift);
        if (!res.success) {

            return res;
        }

        RelationalPost post = {
            .tok = tok,
            .op = op,
            .expr = shift
        };

        sll_append(&(relExpr->postExprs), &post, sizeof(post));
    }

    return (ParseRes){ .success = 
# 1025 "src/parser.c" 3 4
                                 1 
# 1025 "src/parser.c"
                                      };
}

ParseRes parseEqualityExpr(TokenList *tokens, EqualityExpr *eqExpr) {
    eqExpr->tok = tokens->tokens + tokens->pos;

    RelationalExpr relExpr = {0};
    ParseRes res = parseRelationalExpr(tokens, &relExpr);
    if (!res.success) {

        return res;
    }

    eqExpr->baseExpr = relExpr;

    while (peekTok(tokens).type == Token_EqOp ||
        peekTok(tokens).type == Token_NEqOp)
    {
        Token *tok = tokens->tokens + tokens->pos;

        EqualityOp op = consumeTok(tokens).type == Token_EqOp ?
            Equality_Eq : Equality_NEq;

        RelationalExpr rel = {0};
        ParseRes res = parseRelationalExpr(tokens, &rel);
        if (!res.success) {

            return res;
        }

        EqualityPost post = {
            .tok = tok,
            .op = op,
            .expr = rel,
        };

        sll_append(&(eqExpr->postExprs), &post, sizeof(post));
    }

    return (ParseRes){ .success = 
# 1064 "src/parser.c" 3 4
                                 1 
# 1064 "src/parser.c"
                                      };
}

ParseRes parseAndExpr(TokenList *tokens, AndExpr *andExpr) {
    andExpr->tok = tokens->tokens + tokens->pos;

    
# 1070 "src/parser.c" 3 4
   _Bool 
# 1070 "src/parser.c"
        foundAndOp = 
# 1070 "src/parser.c" 3 4
                     0
# 1070 "src/parser.c"
                          ;
    do {
        EqualityExpr eqExpr = {0};
        ParseRes res = parseEqualityExpr(tokens, &eqExpr);
        if (!res.success) {

            return res;
        }

        foundAndOp = consumeIfTok(tokens, '&');

        sll_append(&(andExpr->list), &eqExpr, sizeof(eqExpr));
    } while (foundAndOp);

    return (ParseRes){ .success = 
# 1084 "src/parser.c" 3 4
                                 1 
# 1084 "src/parser.c"
                                      };
}

ParseRes parseExclusiveOrExpr(TokenList *tokens, ExclusiveOrExpr *exclusiveOr) {
    exclusiveOr->tok = tokens->tokens + tokens->pos;

    
# 1090 "src/parser.c" 3 4
   _Bool 
# 1090 "src/parser.c"
        foundOrOp = 
# 1090 "src/parser.c" 3 4
                    0
# 1090 "src/parser.c"
                         ;
    do {
        AndExpr andExpr = {0};
        ParseRes res = parseAndExpr(tokens, &andExpr);
        if (!res.success) {

            return res;
        }

        foundOrOp = consumeIfTok(tokens, '^');

        sll_append(&(exclusiveOr->list), &andExpr, sizeof(andExpr));
    } while (foundOrOp);

    return (ParseRes){ .success = 
# 1104 "src/parser.c" 3 4
                                 1 
# 1104 "src/parser.c"
                                      };
}

ParseRes parseInclusiveOrExpr(TokenList *tokens, InclusiveOrExpr *inclusiveOr) {
    inclusiveOr->tok = tokens->tokens + tokens->pos;

    
# 1110 "src/parser.c" 3 4
   _Bool 
# 1110 "src/parser.c"
        foundOrOp = 
# 1110 "src/parser.c" 3 4
                    0
# 1110 "src/parser.c"
                         ;
    do {
        ExclusiveOrExpr orExpr = {0};
        ParseRes res = parseExclusiveOrExpr(tokens, &orExpr);
        if (!res.success) {

            return res;
        }

        foundOrOp = consumeIfTok(tokens, '|');

        sll_append(&(inclusiveOr->list), &orExpr, sizeof(orExpr));
    } while (foundOrOp);

    return (ParseRes){ .success = 
# 1124 "src/parser.c" 3 4
                                 1 
# 1124 "src/parser.c"
                                      };
}

ParseRes parseLogicalAndExpr(TokenList *tokens, LogicalAndExpr *logicalAnd) {
    logicalAnd->tok = tokens->tokens + tokens->pos;

    
# 1130 "src/parser.c" 3 4
   _Bool 
# 1130 "src/parser.c"
        foundAndOp = 
# 1130 "src/parser.c" 3 4
                     0
# 1130 "src/parser.c"
                          ;
    do {
        InclusiveOrExpr orExpr = {0};
        ParseRes res = parseInclusiveOrExpr(tokens, &orExpr);
        if (!res.success) {

            return res;
        }

        foundAndOp = consumeIfTok(tokens, Token_LogAndOp);

        sll_append(&(logicalAnd->list), &orExpr, sizeof(orExpr));
    } while (foundAndOp);

    return (ParseRes){ .success = 
# 1144 "src/parser.c" 3 4
                                 1 
# 1144 "src/parser.c"
                                      };
}

ParseRes parseLogicalOrExpr(TokenList *tokens, LogicalOrExpr *logicalOr) {
    logicalOr->tok = tokens->tokens + tokens->pos;

    
# 1150 "src/parser.c" 3 4
   _Bool 
# 1150 "src/parser.c"
        foundOrOp = 
# 1150 "src/parser.c" 3 4
                    0
# 1150 "src/parser.c"
                         ;
    do {
        LogicalAndExpr andExpr = {0};
        ParseRes res = parseLogicalAndExpr(tokens, &andExpr);
        if (!res.success) {

            return res;
        }

        foundOrOp = consumeIfTok(tokens, Token_LogOrOp);

        sll_append(&(logicalOr->list), &andExpr, sizeof(andExpr));
    } while (foundOrOp);

    return (ParseRes){ .success = 
# 1164 "src/parser.c" 3 4
                                 1 
# 1164 "src/parser.c"
                                      };
}

ParseRes parseConditionalExpr(TokenList *tokens, ConditionalExpr *conditional) {
    LogicalOrExpr logicalOr = {0};
    ParseRes res = parseLogicalOrExpr(tokens, &logicalOr);
    if (!res.success)
        return res;

    conditional->beforeExpr = logicalOr;

    if (!consumeIfTok(tokens, '?')) {
        conditional->hasConditionalOp = 
# 1176 "src/parser.c" 3 4
                                       0
# 1176 "src/parser.c"
                                            ;
        return (ParseRes){ .success = 
# 1177 "src/parser.c" 3 4
                                     1 
# 1177 "src/parser.c"
                                          };
    }

    Expr expr = {0};
    ParseRes exprRes = parseExpr(tokens, &expr);
    if (!exprRes.success)
        return exprRes;

    if (!consumeIfTok(tokens, ':')) {
        return (ParseRes) {
            .success = 
# 1187 "src/parser.c" 3 4
                      0
# 1187 "src/parser.c"
                           ,
            .failMessage = "Expected : after ? and expr"
        };
    }

    ConditionalExpr falseExpr = {0};
    ParseRes falseRes = parseConditionalExpr(tokens, &falseExpr);
    if (!falseRes.success)
        return falseRes;

    conditional->hasConditionalOp = 
# 1197 "src/parser.c" 3 4
                                   1
# 1197 "src/parser.c"
                                       ;
    conditional->ifTrueExpr = malloc(sizeof(expr));
    memcpy(conditional->ifTrueExpr, &expr, sizeof(expr));
    conditional->ifFalseExpr = malloc(sizeof(falseExpr));
    memcpy(conditional->ifFalseExpr, &falseExpr, sizeof(falseExpr));

    return (ParseRes){ .success = 
# 1203 "src/parser.c" 3 4
                                 1 
# 1203 "src/parser.c"
                                      };
}

ParseRes parseAssignOp(TokenList *tokens, AssignOp *op) {
    if (consumeIfTok(tokens, '=')) {
        *op = Assign_Eq;
    }
    else if (consumeIfTok(tokens, Token_MulAssign)) {
        *op = Assign_MulEq;
    }
    else if (consumeIfTok(tokens, Token_DivAssign)) {
        *op = Assign_DivEq;
    }
    else if (consumeIfTok(tokens, Token_ModAssign)) {
        *op = Assign_ModEq;
    }
    else if (consumeIfTok(tokens, Token_AddAssign)) {
        *op = Assign_AddEq;
    }
    else if (consumeIfTok(tokens, Token_SubAssign)) {
        *op = Assign_SubEq;
    }
    else if (consumeIfTok(tokens, Token_ShiftLeftAssign)) {
        *op = Assign_ShiftLeftEq;
    }
    else if (consumeIfTok(tokens, Token_ShiftRightAssign)) {
        *op = Assign_ShiftRightEq;
    }
    else if (consumeIfTok(tokens, Token_AndAssign)) {
        *op = Assign_AndEq;
    }
    else if (consumeIfTok(tokens, Token_XorAssign)) {
        *op = Assign_XorEq;
    }
    else if (consumeIfTok(tokens, Token_OrAssign)) {
        *op = Assign_OrEq;
    }
    else {
        return (ParseRes) {
            .success = 
# 1242 "src/parser.c" 3 4
                      0
# 1242 "src/parser.c"
                           ,
            .failMessage = "Couldn't find an assignment op"
        };
    }

    return (ParseRes){ .success = 
# 1247 "src/parser.c" 3 4
                                 1 
# 1247 "src/parser.c"
                                      };
}

ParseRes parseAssignExpr(TokenList *tokens, AssignExpr *assignExpr) {

    ParseRes assignRes = {0};
    do {
        size_t preAssignPos = tokens->pos;

        UnaryExpr unaryExpr = {0};
        ParseRes res = parseUnaryExpr(tokens, &unaryExpr);
        if (!res.success) {
            tokens->pos = preAssignPos;
            break;
        }

        AssignOp op = {0};
        assignRes = parseAssignOp(tokens, &op);
        if (!assignRes.success) {
            tokens->pos = preAssignPos;
            break;
        }

        AssignPrefix leftExpr = { unaryExpr, op };

        sll_append(&(assignExpr->leftExprs), &leftExpr, sizeof(leftExpr));
    } while (assignRes.success);


    ConditionalExpr conditional = {0};
    ParseRes res = parseConditionalExpr(tokens, &conditional);
    if (!res.success)
        return res;

    assignExpr->rightExpr = conditional;

    return (ParseRes){ .success = 
# 1283 "src/parser.c" 3 4
                                 1 
# 1283 "src/parser.c"
                                      };
}

ParseRes parseInnerExpr(TokenList *tokens, InnerExpr *inner) {
    size_t pos = tokens->pos;


    if (!consumeIfTok(tokens, '('))
        goto ParseInnerExpr_AfterCompound;

    CompoundStmt compound = {0};
    if (!parseCompoundStmt(tokens, &compound).success)
        goto ParseInnerExpr_AfterCompound;

    if (!consumeIfTok(tokens, ')'))
        goto ParseInnerExpr_AfterCompound;

    inner->type = InnerExpr_CompoundStatement;
    inner->compoundStmt = malloc(sizeof(compound));
    memcpy(inner->compoundStmt, &compound, sizeof(compound));

    return (ParseRes){ .success = 
# 1304 "src/parser.c" 3 4
                                 1 
# 1304 "src/parser.c"
                                      };

ParseInnerExpr_AfterCompound:
    tokens->pos = pos;


    AssignExpr expr = {0};
    if (!parseAssignExpr(tokens, &expr).success)
        goto ParseInnerExpr_AfterAssign;

    inner->type = InnerExpr_Assign;
    inner->assign = expr;

    return (ParseRes){ .success = 
# 1317 "src/parser.c" 3 4
                                 1 
# 1317 "src/parser.c"
                                      };

ParseInnerExpr_AfterAssign:

    return (ParseRes) {
        .success = 
# 1322 "src/parser.c" 3 4
                  0
# 1322 "src/parser.c"
                       ,
        .failMessage = "Couldn't parse an inner expr"
    };
}

ParseRes parseExpr(TokenList *tokens, Expr *expr) {
    
# 1328 "src/parser.c" 3 4
   _Bool 
# 1328 "src/parser.c"
        hasComma = 
# 1328 "src/parser.c" 3 4
                   0
# 1328 "src/parser.c"
                        ;

    do {
        size_t pos = tokens->pos;

        InnerExpr inner = {0};
        ParseRes res = parseInnerExpr(tokens, &inner);
        if (!res.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(&(expr->list), &inner, sizeof(inner));

        hasComma = consumeIfTok(tokens, ',');

    } while(hasComma);


    if (expr->list.size == 0) {
        return (ParseRes) {
            .success = 
# 1349 "src/parser.c" 3 4
                      0
# 1349 "src/parser.c"
                           ,
            .failMessage = "Expr needs at least one inner expr"
        };
    }

    return (ParseRes){ .success = 
# 1354 "src/parser.c" 3 4
                                 1 
# 1354 "src/parser.c"
                                      };
}

ParseRes parseParameterDeclaration(TokenList *tokens, ParameterDeclaration *decl) {
    DeclarationSpecifierList list = {0};
    ParseRes res = parseDeclarationSpecifierList(tokens, &list);
    if (!res.success)
        return res;

    decl->declarationSpecifiers = malloc(sizeof(list));
    memcpy(decl->declarationSpecifiers, &list, sizeof(list));

    size_t beforeDeclaratorPos = tokens->pos;

    Declarator declarator = {0};
    if (parseDeclarator(tokens, &declarator).success) {
        decl->hasDeclarator = 
# 1370 "src/parser.c" 3 4
                             1
# 1370 "src/parser.c"
                                 ;
        decl->hasAbstractDeclarator = 
# 1371 "src/parser.c" 3 4
                                     0
# 1371 "src/parser.c"
                                          ;
        decl->declarator = malloc(sizeof(declarator));
        memcpy(decl->declarator, &declarator, sizeof(declarator));
        return (ParseRes){ .success = 
# 1374 "src/parser.c" 3 4
                                     1 
# 1374 "src/parser.c"
                                          };
    }

    tokens->pos = beforeDeclaratorPos;



    size_t beforeAbstractDeclaratorPos = tokens->pos;

    AbstractDeclarator abstractDeclarator = {0};
    if (parseAbstractDeclarator(tokens, &abstractDeclarator).success) {
        decl->hasAbstractDeclarator = 
# 1385 "src/parser.c" 3 4
                                     1
# 1385 "src/parser.c"
                                         ;
        decl->hasDeclarator = 
# 1386 "src/parser.c" 3 4
                             0
# 1386 "src/parser.c"
                                  ;
        decl->abstractDeclarator = malloc(sizeof(abstractDeclarator));
        memcpy(decl->abstractDeclarator, &abstractDeclarator, sizeof(abstractDeclarator));
        return (ParseRes){ .success = 
# 1389 "src/parser.c" 3 4
                                     1 
# 1389 "src/parser.c"
                                          };
    }

    tokens->pos = beforeAbstractDeclaratorPos;

    return (ParseRes){ .success = 
# 1394 "src/parser.c" 3 4
                                 1 
# 1394 "src/parser.c"
                                      };
}

ParseRes parseParameterTypeList(TokenList *tokens, ParameterTypeList *list) {
    
# 1398 "src/parser.c" 3 4
   _Bool 
# 1398 "src/parser.c"
        hasComma = 
# 1398 "src/parser.c" 3 4
                   0
# 1398 "src/parser.c"
                        ;
    do {

        if (consumeIfTok(tokens, Token_Ellipsis)) {
            list->hasEndingEllipsis = 
# 1402 "src/parser.c" 3 4
                                     1
# 1402 "src/parser.c"
                                         ;
            break;
        }

        ParameterDeclaration decl = {0};
        ParseRes paramRes = parseParameterDeclaration(tokens, &decl);
        if (!paramRes.success) {
            return (ParseRes) {
                .success = 
# 1410 "src/parser.c" 3 4
                          0
# 1410 "src/parser.c"
                               ,
                .failMessage = "Expected parameter declaration in type list"
            };
        }

        sll_append(&(list->paramDecls), &decl, sizeof(decl));

        hasComma = consumeIfTok(tokens, ',');

    } while(hasComma);

    return (ParseRes){ .success = 
# 1421 "src/parser.c" 3 4
                                 1 
# 1421 "src/parser.c"
                                      };
}

ParseRes parsePostDirectAbstractDeclarator(TokenList *tokens,
    PostDirectAbstractDeclarator *postDeclarator)
{

    size_t bracketPos = tokens->pos;

    if (!consumeIfTok(tokens, '['))
        goto PostDirectAbstractDeclarator_Paren;




    if (consumeIfTok(tokens, ']')) {
        postDeclarator->type = PostDirectAbstractDeclarator_Bracket;
        postDeclarator->bracketIsEmpty = 
# 1438 "src/parser.c" 3 4
                                        1
# 1438 "src/parser.c"
                                            ;
        return (ParseRes){ .success = 
# 1439 "src/parser.c" 3 4
                                     1 
# 1439 "src/parser.c"
                                          };
    }


    if (peekAheadTok(tokens, 0).type == '*' &&
        peekAheadTok(tokens, 1).type == ']')
    {
        consumeMulti(tokens, 2);
        postDeclarator->type = PostDirectAbstractDeclarator_Bracket;
        postDeclarator->bracketIsStar = 
# 1448 "src/parser.c" 3 4
                                       1
# 1448 "src/parser.c"
                                           ;
        return (ParseRes){ .success = 
# 1449 "src/parser.c" 3 4
                                     1 
# 1449 "src/parser.c"
                                          };
    }


    {
        if (consumeIfTok(tokens, Token_static))
            postDeclarator->bracketHasInitialStatic = 
# 1455 "src/parser.c" 3 4
                                                     1
# 1455 "src/parser.c"
                                                         ;


        ParseRes res = {0};
        do {
            size_t typeQualifierPos = tokens->pos;

            TypeQualifier typeQualifier = {0};
            res = parseTypeQualifier(tokens, &typeQualifier);
            if (!res.success) {
                tokens->pos = typeQualifierPos;
                break;
            }

            sll_append(&(postDeclarator->bracketTypeQualifiers), &typeQualifier, sizeof(typeQualifier));
        } while (res.success);


        if (consumeIfTok(tokens, Token_static))
            postDeclarator->bracketHasMiddleStatic = 
# 1474 "src/parser.c" 3 4
                                                    1
# 1474 "src/parser.c"
                                                        ;


        size_t assignPos = tokens->pos;

        AssignExpr assignExpr = {0};
        ParseRes assignRes = parseAssignExpr(tokens, &assignExpr);
        if (assignRes.success) {
            postDeclarator->bracketHasAssignmentExpr = 
# 1482 "src/parser.c" 3 4
                                                      1
# 1482 "src/parser.c"
                                                          ;
            postDeclarator->bracketAssignExpr = assignExpr;
        }
        else {
            postDeclarator->bracketHasAssignmentExpr = 
# 1486 "src/parser.c" 3 4
                                                      0
# 1486 "src/parser.c"
                                                           ;
            tokens->pos = assignPos;
        }


        {

            if (postDeclarator->bracketHasInitialStatic &&
                postDeclarator->bracketHasMiddleStatic)
            {
                return (ParseRes) {
                    .success = 
# 1497 "src/parser.c" 3 4
                              0
# 1497 "src/parser.c"
                                   ,
                    .failMessage = "Direct abstract declarator can't have 2 statics in brackets"
                };
            }
            if (postDeclarator->bracketTypeQualifiers.size == 0 &&
                !postDeclarator->bracketHasAssignmentExpr)
            {
                return (ParseRes) {
                    .success = 
# 1505 "src/parser.c" 3 4
                              0
# 1505 "src/parser.c"
                                   ,
                    .failMessage = "Direct abstract declarator must have at least a type qualifier list or assignment expr"
                };
            }
        }

        return (ParseRes) { .success = 
# 1511 "src/parser.c" 3 4
                                      1 
# 1511 "src/parser.c"
                                           };
    }


PostDirectAbstractDeclarator_Paren:
    memset(postDeclarator, 0, sizeof(PostDirectAbstractDeclarator));
    tokens->pos = bracketPos;


    if (!consumeIfTok(tokens, '(')) {
        return (ParseRes) {
            .success = 
# 1522 "src/parser.c" 3 4
                      0
# 1522 "src/parser.c"
                           ,
            .failMessage = "Expected ( for direct abstract declarator"
        };
    }

    if (consumeIfTok(tokens, ')')) {

        postDeclarator->type = PostDirectAbstractDeclarator_Paren;
        postDeclarator->parenIsEmpty = 
# 1530 "src/parser.c" 3 4
                                      1
# 1530 "src/parser.c"
                                          ;

        return (ParseRes){ .success = 
# 1532 "src/parser.c" 3 4
                                     1 
# 1532 "src/parser.c"
                                          };
    }

    ParameterTypeList paramList = {0};
    ParseRes res = parseParameterTypeList(tokens, &paramList);
    if (!res.success)
        return res;

    if (!consumeIfTok(tokens, ')')) {
        return (ParseRes) {
            .success = 
# 1542 "src/parser.c" 3 4
                      0
# 1542 "src/parser.c"
                           ,
            .failMessage = "Expected ) after param list for direct abstract declarator"
        };
    }

    postDeclarator->type = PostDirectAbstractDeclarator_Paren;
    postDeclarator->parenParamList = paramList;

    return (ParseRes){ .success = 
# 1550 "src/parser.c" 3 4
                                 1 
# 1550 "src/parser.c"
                                      };
}

ParseRes parseDirectAbstractDeclarator(TokenList *tokens,
    DirectAbstractDeclarator *directDeclarator)
{

    size_t preAbstractDeclaratorPos = tokens->pos;

    if (!consumeIfTok(tokens, '('))
        goto PostAbstractDeclaratorFail;

    AbstractDeclarator abstractDeclarator = {0};
    ParseRes abstractRes = parseAbstractDeclarator(tokens, &abstractDeclarator);
    if (!abstractRes.success) {
        goto PostAbstractDeclaratorFail;
    }

    if (!consumeIfTok(tokens, ')'))
        goto PostAbstractDeclaratorFail;


    directDeclarator->hasAbstractDeclarator = 
# 1572 "src/parser.c" 3 4
                                             1
# 1572 "src/parser.c"
                                                 ;
    directDeclarator->abstractDeclarator = malloc(sizeof(abstractDeclarator));
    memcpy(directDeclarator->abstractDeclarator, &abstractDeclarator, sizeof(abstractDeclarator));

    goto PostAbstractDeclaratorDone;

PostAbstractDeclaratorFail:
    directDeclarator->hasAbstractDeclarator = 
# 1579 "src/parser.c" 3 4
                                             0
# 1579 "src/parser.c"
                                                  ;
    tokens->pos = preAbstractDeclaratorPos;

PostAbstractDeclaratorDone:
    ;

    ParseRes res = {0};
    do {

        size_t pos = tokens->pos;

        PostDirectAbstractDeclarator postDeclarator = {0};
        res = parsePostDirectAbstractDeclarator(tokens, &postDeclarator);
        if (!res.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(&(directDeclarator->postDirectAbstractDeclarators), &postDeclarator, sizeof(postDeclarator))
                           ;
    } while (res.success);

    if (!directDeclarator->hasAbstractDeclarator &&
        directDeclarator->postDirectAbstractDeclarators.size == 0)
    {
        return (ParseRes) {
            .success = 
# 1605 "src/parser.c" 3 4
                      0
# 1605 "src/parser.c"
                           ,
            .failMessage = "Couldn't parse a direct abstract declarator"
        };
    }

    return (ParseRes){ .success = 
# 1610 "src/parser.c" 3 4
                                 1 
# 1610 "src/parser.c"
                                      };
}

ParseRes parsePointer(TokenList *tokens, Pointer *pointer) {
    if (peekTok(tokens).type != '*') {
        return (ParseRes) {
            .success = 
# 1616 "src/parser.c" 3 4
                      0
# 1616 "src/parser.c"
                           ,
            .failMessage = "Pointer didn't start with *"
        };
    }

    while (peekTok(tokens).type == '*') {
        consumeTok(tokens);
        pointer->numPtrs++;
    }


    ParseRes typeQualifierRes = {0};
    do {
        size_t pos = tokens->pos;

        TypeQualifier typeQualifier = {0};
        typeQualifierRes = parseTypeQualifier(tokens, &typeQualifier);
        if (!typeQualifierRes.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(&(pointer->typeQualifiers), &typeQualifier, sizeof(typeQualifier));
    } while (typeQualifierRes.success);


    if (pointer->typeQualifiers.size == 0) {
        pointer->hasPtr = 
# 1643 "src/parser.c" 3 4
                         0
# 1643 "src/parser.c"
                              ;
        return (ParseRes){ .success = 
# 1644 "src/parser.c" 3 4
                                     1 
# 1644 "src/parser.c"
                                          };
    }


    size_t pos = tokens->pos;

    Pointer trailingPointer = {0};
    ParseRes pointerRes = parsePointer(tokens, &trailingPointer);
    if (pointerRes.success) {
        pointer->hasPtr = 
# 1653 "src/parser.c" 3 4
                         1
# 1653 "src/parser.c"
                             ;
        pointer->pointer = malloc(sizeof(Pointer));
        memcpy(pointer->pointer, &trailingPointer, sizeof(Pointer));
    }
    else {
        pointer->hasPtr = 
# 1658 "src/parser.c" 3 4
                         0
# 1658 "src/parser.c"
                              ;
        tokens->pos = pos;
    }

    return (ParseRes){ .success = 
# 1662 "src/parser.c" 3 4
                                 1 
# 1662 "src/parser.c"
                                      };
}

ParseRes parseAbstractDeclarator(TokenList *tokens,
    AbstractDeclarator *abstractDeclarator)
{

    size_t pointerPos = tokens->pos;

    Pointer pointer = {0};
    ParseRes pointerRes = parsePointer(tokens, &pointer);
    if (pointerRes.success) {
        abstractDeclarator->hasPointer = 
# 1674 "src/parser.c" 3 4
                                        1
# 1674 "src/parser.c"
                                            ;
        abstractDeclarator->pointer = pointer;
    }
    else {
        abstractDeclarator->hasPointer = 
# 1678 "src/parser.c" 3 4
                                        0
# 1678 "src/parser.c"
                                             ;
        tokens->pos = pointerPos;
    }


    size_t directPos = tokens->pos;

    DirectAbstractDeclarator directDeclarator = {0};
    ParseRes directRes = parseDirectAbstractDeclarator(tokens, &directDeclarator);
    if (directRes.success) {
        abstractDeclarator->hasDirectAbstractDeclarator = 
# 1688 "src/parser.c" 3 4
                                                         1
# 1688 "src/parser.c"
                                                             ;
        abstractDeclarator->directAbstractDeclarator = directDeclarator;
    }
    else {
        abstractDeclarator->hasDirectAbstractDeclarator = 
# 1692 "src/parser.c" 3 4
                                                         0
# 1692 "src/parser.c"
                                                              ;
        tokens->pos = directPos;
    }

    if (!abstractDeclarator->hasPointer &&
        !abstractDeclarator->hasDirectAbstractDeclarator)
    {

        return (ParseRes) {
            .success = 
# 1701 "src/parser.c" 3 4
                      0
# 1701 "src/parser.c"
                           ,
            .failMessage = "Couldn't parse a pointer or direct "
                "abstract declarator in an abstract declarator"
        };
    }

    return (ParseRes) { .success = 
# 1707 "src/parser.c" 3 4
                                  1 
# 1707 "src/parser.c"
                                       };
}

ParseRes parseIdentifierList(TokenList *tokens, IdentifierList *list) {
    
# 1711 "src/parser.c" 3 4
   _Bool 
# 1711 "src/parser.c"
        hasComma = 
# 1711 "src/parser.c" 3 4
                   0
# 1711 "src/parser.c"
                        ;
    do {
        if (peekTok(tokens).type != Token_Ident) {
            break;
        }

        Token tok = consumeTok(tokens);
        sll_append(&(list->list), &tok.ident, sizeof(tok.ident));

        hasComma = consumeIfTok(tokens, Token_Ident);

    } while (hasComma);

    return (ParseRes){ .success = 
# 1724 "src/parser.c" 3 4
                                 1 
# 1724 "src/parser.c"
                                      };
}

ParseRes parsePostDirectDeclarator(TokenList *tokens, PostDirectDeclarator *postDeclarator) {

    if (consumeIfTok(tokens, '[')) {

        postDeclarator->type = PostDirectDeclarator_Bracket;


        if (consumeIfTok(tokens, ']')) {
            postDeclarator->bracketIsEmpty = 
# 1735 "src/parser.c" 3 4
                                            1
# 1735 "src/parser.c"
                                                ;
            return (ParseRes){ .success = 
# 1736 "src/parser.c" 3 4
                                         1 
# 1736 "src/parser.c"
                                              };
        }


        if (peekAheadTok(tokens, 0).type == '*' &&
            peekAheadTok(tokens, 1).type == ']')
        {
            consumeTok(tokens);
            consumeTok(tokens);
            postDeclarator->bracketIsStar = 
# 1745 "src/parser.c" 3 4
                                           1
# 1745 "src/parser.c"
                                               ;
            return (ParseRes){ .success = 
# 1746 "src/parser.c" 3 4
                                         1 
# 1746 "src/parser.c"
                                              };
        }


        {

            if (consumeIfTok(tokens, Token_static)) {
                postDeclarator->bracketHasInitialStatic = 
# 1753 "src/parser.c" 3 4
                                                         1
# 1753 "src/parser.c"
                                                             ;
            }


            ParseRes res = {0};
            do {
                size_t typeQualifierPos = tokens->pos;

                TypeQualifier typeQualifier = {0};
                res = parseTypeQualifier(tokens, &typeQualifier);
                if (!res.success) {
                    tokens->pos = typeQualifierPos;
                    break;
                }

                sll_append(&(postDeclarator->bracketTypeQualifiers), &typeQualifier, sizeof(typeQualifier))
                                  ;
            } while (res.success);






            if (!postDeclarator->bracketHasInitialStatic &&
                postDeclarator->bracketTypeQualifiers.size > 0 &&
                peekAheadTok(tokens, 0).type == '*' &&
                peekAheadTok(tokens, 1).type == ']')
            {
                consumeTok(tokens);
                consumeTok(tokens);

                postDeclarator->bracketHasStarAfterTypeQualifiers = 
# 1785 "src/parser.c" 3 4
                                                                   1
# 1785 "src/parser.c"
                                                                       ;
                return (ParseRes){ .success = 
# 1786 "src/parser.c" 3 4
                                             1 
# 1786 "src/parser.c"
                                                  };
            }


            if (consumeIfTok(tokens, Token_static)) {
                postDeclarator->bracketHasMiddleStatic = 
# 1791 "src/parser.c" 3 4
                                                        1
# 1791 "src/parser.c"
                                                            ;
            }


            size_t preAssignPos = tokens->pos;
            AssignExpr expr = {0};
            if (parseAssignExpr(tokens, &expr).success) {
                postDeclarator->bracketHasAssignExpr = 
# 1798 "src/parser.c" 3 4
                                                      1
# 1798 "src/parser.c"
                                                          ;
                postDeclarator->bracketAssignExpr = expr;
            }
            else {
                tokens->pos = preAssignPos;
            }

            if (!consumeIfTok(tokens, ']')) {
                return (ParseRes) {
                    .success = 
# 1807 "src/parser.c" 3 4
                              0
# 1807 "src/parser.c"
                                   ,
                    .failMessage = "Expected ] after expr in pos direct declarator"
                };
            }


            {

                if (postDeclarator->bracketHasInitialStatic &&
                    postDeclarator->bracketHasMiddleStatic)
                {
                    return (ParseRes) {
                        .success = 
# 1819 "src/parser.c" 3 4
                                  0
# 1819 "src/parser.c"
                                       ,
                        .failMessage = "Post direct declarator cannot have 2 statics"
                    };
                }


                if (postDeclarator->bracketTypeQualifiers.size == 0 &&
                    !postDeclarator->bracketHasAssignExpr)
                {
                    return (ParseRes) {
                        .success = 
# 1829 "src/parser.c" 3 4
                                  0
# 1829 "src/parser.c"
                                       ,
                        .failMessage = "Post direct declarator must have at least a type qualifier or assignment expr"
                    };
                }
            }

            return (ParseRes){ .success = 
# 1835 "src/parser.c" 3 4
                                         1 
# 1835 "src/parser.c"
                                              };
        }
    }


    if (consumeIfTok(tokens, '(')) {

        postDeclarator->type = PostDirectDeclarator_Paren;


        if (consumeIfTok(tokens, ')')) {
            postDeclarator->parenType = PostDirectDeclaratorParen_Empty;
            return (ParseRes){ .success = 
# 1847 "src/parser.c" 3 4
                                         1 
# 1847 "src/parser.c"
                                              };
        }

        size_t pos = tokens->pos;


        {
            ParameterTypeList paramList = {0};
            ParseRes paramRes = parseParameterTypeList(tokens, &paramList);
            if (!paramRes.success)
                goto ParsePostDirectDeclarator_PostParenParamList;

            postDeclarator->parenType = PostDirectDeclaratorParen_ParamTypelist;
            postDeclarator->parenParamTypeList = paramList;

            if (!consumeIfTok(tokens, ')'))
                goto ParsePostDirectDeclarator_PostParenParamList;

            return (ParseRes){ .success = 
# 1865 "src/parser.c" 3 4
                                         1 
# 1865 "src/parser.c"
                                              };
        }

ParsePostDirectDeclarator_PostParenParamList:

        tokens->pos = pos;


        {
            IdentifierList identList = {0};
            ParseRes identRes = parseIdentifierList(tokens, &identList);
            if (!identRes.success) {
                return (ParseRes) {
                    .success = 
# 1878 "src/parser.c" 3 4
                              0
# 1878 "src/parser.c"
                                   ,
                    .failMessage = "Expected identifier list after ( in direct declarator"
                };
            }

            postDeclarator->parenType = PostDirectDeclaratorParen_IdentList;
            postDeclarator->parenIdentList = identList;

            if (!consumeIfTok(tokens, ')')) {
                return (ParseRes) {
                    .success = 
# 1888 "src/parser.c" 3 4
                              0
# 1888 "src/parser.c"
                                   ,
                    .failMessage = "Expected ) after identifier list"
                };
            }

            return (ParseRes){ .success = 
# 1893 "src/parser.c" 3 4
                                         1 
# 1893 "src/parser.c"
                                              };

        }

        return (ParseRes) {
            .success = 
# 1898 "src/parser.c" 3 4
                      0
# 1898 "src/parser.c"
                           ,
            .failMessage = "Expected either a parameter list or identifier list after ( in post direct declarator"
        };
    }

    return (ParseRes) {
        .success = 
# 1904 "src/parser.c" 3 4
                  0
# 1904 "src/parser.c"
                       ,
        .failMessage = "Expected either ( or [ in post direct declarator"
    };
}

ParseRes parseDirectDeclarator(TokenList *tokens, DirectDeclarator *directDeclarator) {

    if (peekTok(tokens).type == Token_Ident) {
        Token ident = consumeTok(tokens);
        directDeclarator->type = DirectDeclarator_Ident;
        directDeclarator->ident = ident.ident;
    }
    else if (consumeIfTok(tokens, '(')) {
        Declarator nestedDeclarator = {0};
        ParseRes nestedDeclRes = parseDeclarator(tokens, &nestedDeclarator);
        if (!nestedDeclRes.success)
            return nestedDeclRes;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 1924 "src/parser.c" 3 4
                          0
# 1924 "src/parser.c"
                               ,
                .failMessage = "Expected ) after direct declarator's nested declarator"
            };
        }

        directDeclarator->type = DirectDeclarator_ParenDeclarator;
        directDeclarator->declarator = malloc(sizeof(nestedDeclarator));
        memcpy(directDeclarator->declarator, &nestedDeclarator, sizeof(nestedDeclarator));
    }
    else {
        return (ParseRes) {
            .success = 
# 1935 "src/parser.c" 3 4
                      0
# 1935 "src/parser.c"
                           ,
            .failMessage = "Expected ( or ident for direct declarator"
        };
    }


    ParseRes postDirectRes = {0};
    do {
        size_t pos = tokens->pos;

        PostDirectDeclarator postDeclarator = {0};
        postDirectRes = parsePostDirectDeclarator(tokens, &postDeclarator);
        if (!postDirectRes.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(&(directDeclarator->postDirectDeclarators), &postDeclarator, sizeof(postDeclarator))
                           ;
    } while(postDirectRes.success);

    return (ParseRes) { .success = 
# 1956 "src/parser.c" 3 4
                                  1 
# 1956 "src/parser.c"
                                       };
}

ParseRes parseDeclarator(TokenList *tokens, Declarator *declarator) {
    declarator->tok = tokens->tokens + tokens->pos;


    size_t prePointerPos = tokens->pos;

    Pointer pointer = {0};
    if (parsePointer(tokens, &pointer).success) {
        declarator->hasPointer = 
# 1967 "src/parser.c" 3 4
                                1
# 1967 "src/parser.c"
                                    ;
        declarator->pointer = pointer;
    }
    else {
        tokens->pos = prePointerPos;
        declarator->hasPointer = 
# 1972 "src/parser.c" 3 4
                                0
# 1972 "src/parser.c"
                                     ;
    }


    DirectDeclarator direct = {0};
    ParseRes res = parseDirectDeclarator(tokens, &direct);
    if (!res.success) {
        return res;
    }

    declarator->directDeclarator = direct;
    return (ParseRes){ .success = 
# 1983 "src/parser.c" 3 4
                                 1 
# 1983 "src/parser.c"
                                      };
}

ParseRes parseTypeQualifier(TokenList *tokens, TypeQualifier *outQualifier) {
    ParseRes pass = { .success = 
# 1987 "src/parser.c" 3 4
                                1 
# 1987 "src/parser.c"
                                     };
    ParseRes fail = {
        .success = 
# 1989 "src/parser.c" 3 4
                  0
# 1989 "src/parser.c"
                       ,
        .failMessage = "Couldn't parse type qualifier"
    };

    if (consumeIfTok(tokens, Token_const)) {
        *outQualifier = Qualifier_Const;
        return pass;
    }
    if (consumeIfTok(tokens, Token_restrict)) {
        *outQualifier = Qualifier_Restrict;
        return pass;
    }
    if (consumeIfTok(tokens, Token_volatile)) {
        *outQualifier = Qualifier_Volatile;
        return pass;
    }
    if (consumeIfTok(tokens, Token_atomic)) {
        *outQualifier = Qualifier_Atomic;
        return pass;
    }

    return fail;
}

ParseRes parseSpecifierQualifier(TokenList *tokens,
    SpecifierQualifier *outSpecifierQualifier)
{

    size_t pos = tokens->pos;

    TypeSpecifier specifier = {0};
    ParseRes specifierRes = parseTypeSpecifier(tokens, &specifier);
    if (specifierRes.success) {
        outSpecifierQualifier->type = SpecifierQualifier_Specifier;
        outSpecifierQualifier->typeSpecifier = malloc(sizeof(specifier));
        memcpy(outSpecifierQualifier->typeSpecifier, &specifier, sizeof(specifier));
        return (ParseRes){ .success = 
# 2025 "src/parser.c" 3 4
                                     1 
# 2025 "src/parser.c"
                                          };
    }

    tokens->pos = pos;

    TypeQualifier qualifier = {0};
    ParseRes qualifierRes = parseTypeQualifier(tokens, &qualifier);
    if (qualifierRes.success) {
        outSpecifierQualifier->type = SpecifierQualifier_Qualifier;
        outSpecifierQualifier->typeQualifier = qualifier;
        return (ParseRes){ .success = 
# 2035 "src/parser.c" 3 4
                                     1 
# 2035 "src/parser.c"
                                          };
    }


    return (ParseRes) {
        .success = 
# 2040 "src/parser.c" 3 4
                  0
# 2040 "src/parser.c"
                       ,
        .failMessage = "Couldn't parse specifier-qualifier"
    };
}

ParseRes parseSpecifierQualifierList(TokenList *tokens,
    SpecifierQualifierList *outList)
{

    SpecifierQualifier specifierQualifier = {0};
    ParseRes res = parseSpecifierQualifier(tokens, &specifierQualifier);
    if (!res.success) {
        return res;
    }

    do {
        sll_append(&(outList->list), &specifierQualifier, sizeof(specifierQualifier));
        res = parseSpecifierQualifier(tokens, &specifierQualifier);
    } while (res.success);

    return (ParseRes) { .success = 
# 2060 "src/parser.c" 3 4
                                  1 
# 2060 "src/parser.c"
                                       };
}

ParseRes parseTypeName(TokenList *tokens, TypeName *outType) {

    SpecifierQualifierList list = {0};
    ParseRes res = parseSpecifierQualifierList(tokens, &list);
    if (!res.success) {
        return res;
    }

    outType->specifierQualifiers = list;


    size_t pos = tokens->pos;

    AbstractDeclarator abstractDeclarator = {0};
    ParseRes abstractRes = parseAbstractDeclarator(tokens, &abstractDeclarator);
    if (abstractRes.success) {
        outType->hasAbstractDeclarator = 
# 2079 "src/parser.c" 3 4
                                        1
# 2079 "src/parser.c"
                                            ;
        outType->abstractDeclarator = abstractDeclarator;
        return (ParseRes){ .success = 
# 2081 "src/parser.c" 3 4
                                     1 
# 2081 "src/parser.c"
                                          };
    }


    tokens->pos = pos;

    outType->hasAbstractDeclarator = 
# 2087 "src/parser.c" 3 4
                                    0
# 2087 "src/parser.c"
                                         ;

    return (ParseRes){ .success = 
# 2089 "src/parser.c" 3 4
                                 1 
# 2089 "src/parser.c"
                                      };
}

ParseRes parseStorageClassSpecifier(TokenList *tokens,
    StorageClassSpecifier *outSpec)
{
    ParseRes pass = { .success = 
# 2095 "src/parser.c" 3 4
                                1 
# 2095 "src/parser.c"
                                     };
    ParseRes fail = {
        .success = 
# 2097 "src/parser.c" 3 4
                  0
# 2097 "src/parser.c"
                       ,
        .failMessage = "Couldn't parse storage class specifier"
    };

    if (consumeIfTok(tokens, Token_typedef)) {
        *outSpec = StorageClass_Typedef;
        return pass;
    }
    else if (consumeIfTok(tokens, Token_extern)) {
        *outSpec = StorageClass_Extern;
        return pass;
    }
    else if (consumeIfTok(tokens, Token_static)) {
        *outSpec = StorageClass_Static;
        return pass;
    }
    else if (consumeIfTok(tokens, Token_threadLocal)) {
        *outSpec = StorageClass_Thread_Local;
        return pass;
    }
    else if (consumeIfTok(tokens, Token_auto)) {
        *outSpec = StorageClass_Auto;
        return pass;
    }
    else if (consumeIfTok(tokens, Token_register)) {
        *outSpec = StorageClass_Register;
        return pass;
    }

    return fail;
}

ParseRes parseStaticAssertDeclaration(TokenList *tokens, StaticAssertDeclaration *decl) {
    if (!consumeIfTok(tokens, Token_staticAssert)) {
        return (ParseRes) {
            .success = 
# 2132 "src/parser.c" 3 4
                      0
# 2132 "src/parser.c"
                           ,
            .failMessage = "Expected static assert at front of static assert declaration"
        };
    }

    if (!consumeIfTok(tokens, '(')) {
        return (ParseRes) {
            .success = 
# 2139 "src/parser.c" 3 4
                      0
# 2139 "src/parser.c"
                           ,
            .failMessage = "Expected ( after static assert declaration"
        };
    }

    ConditionalExpr constant = {0};
    ParseRes constantRes = parseConditionalExpr(tokens, &constant);
    if (!constantRes.success)
        return constantRes;

    if (!consumeIfTok(tokens, ',')) {
        return (ParseRes) {
            .success = 
# 2151 "src/parser.c" 3 4
                      0
# 2151 "src/parser.c"
                           ,
            .failMessage = "Expected , after constant in static assert declaration"
        };
    }

    if (peekTok(tokens).type != Token_ConstString) {
        return (ParseRes) {
            .success = 
# 2158 "src/parser.c" 3 4
                      0
# 2158 "src/parser.c"
                           ,
            .failMessage = "Expected string after , in static assert declaration"
        };
    }


    while (peekTok(tokens).type == Token_ConstString)
        consumeTok(tokens);

    Token string = consumeTok(tokens);

    if (!consumeIfTok(tokens, ')')) {
        return (ParseRes) {
            .success = 
# 2171 "src/parser.c" 3 4
                      0
# 2171 "src/parser.c"
                           ,
            .failMessage = "Expected ) after string in static assert declaration"
        };
    }

    if (!consumeIfTok(tokens, ';')) {
        return (ParseRes) {
            .success = 
# 2178 "src/parser.c" 3 4
                      0
# 2178 "src/parser.c"
                           ,
            .failMessage = "Expected ; after ) in static assert declaration"
        };
    }

    decl->constantExpr = constant;
    decl->stringLiteral = string.constString;

    return (ParseRes) { .success = 
# 2186 "src/parser.c" 3 4
                                  1 
# 2186 "src/parser.c"
                                       };
}

ParseRes parseStructDeclarator(TokenList *tokens, StructDeclarator *decl) {
    size_t posBefore = tokens->pos;

    Declarator declarator = {0};
    ParseRes declaratorRes = parseDeclarator(tokens, &declarator);
    if (declaratorRes.success) {
        decl->hasDeclarator = 
# 2195 "src/parser.c" 3 4
                             1
# 2195 "src/parser.c"
                                 ;
        decl->declarator = declarator;
    }
    else {
        tokens->pos = posBefore;
    }

    if (consumeIfTok(tokens, ':')) {

        ConditionalExpr expr = {0};
        ParseRes exprRes = parseConditionalExpr(tokens, &expr);
        if (!exprRes.success)
            return exprRes;

        decl->hasConstExpr = 
# 2209 "src/parser.c" 3 4
                            1
# 2209 "src/parser.c"
                                ;
        decl->constExpr = expr;
    }

    return (ParseRes){ .success = 
# 2213 "src/parser.c" 3 4
                                 1 
# 2213 "src/parser.c"
                                      };
}

ParseRes parseStructDeclaratorList(TokenList *tokens, StructDeclaratorList *declList) {
    
# 2217 "src/parser.c" 3 4
   _Bool 
# 2217 "src/parser.c"
        hasComma = 
# 2217 "src/parser.c" 3 4
                   0
# 2217 "src/parser.c"
                        ;
    do {
        StructDeclarator decl = {0};
        ParseRes res = parseStructDeclarator(tokens, &decl);
        if (!res.success)
            return res;

        sll_append(&(declList->list), &decl, sizeof(decl));

        hasComma = consumeIfTok(tokens, ',');
    } while(hasComma);

    return (ParseRes){ .success = 
# 2229 "src/parser.c" 3 4
                                 1 
# 2229 "src/parser.c"
                                      };
}

ParseRes parseStructDeclaration(TokenList *tokens, StructDeclaration *declaration) {

    if (peekTok(tokens).type == Token_staticAssert) {
        StaticAssertDeclaration staticAssert = {0};
        ParseRes staticRes = parseStaticAssertDeclaration(tokens, &staticAssert);
        if (!staticRes.success)
            return staticRes;

        declaration->type = StructDeclaration_StaticAssert;
        declaration->staticAssert = staticAssert;

        return (ParseRes){ .success = 
# 2243 "src/parser.c" 3 4
                                     1 
# 2243 "src/parser.c"
                                          };
    }



    SpecifierQualifierList list = {0};
    ParseRes listRes = parseSpecifierQualifierList(tokens, &list);
    if (!listRes.success)
        return listRes;

    declaration->type = StructDeclaration_Normal;
    declaration->normalSpecifierQualifiers = list;


    size_t preDeclaratorPos = tokens->pos;

    StructDeclaratorList declList = {0};
    ParseRes declRes = parseStructDeclaratorList(tokens, &declList);
    if (declRes.success) {
        declaration->normalHasStructDeclaratorList = 
# 2262 "src/parser.c" 3 4
                                                    1
# 2262 "src/parser.c"
                                                        ;
        declaration->normalStructDeclaratorList = declList;
    }
    else {
        tokens->pos = preDeclaratorPos;
    }


    if (!consumeIfTok(tokens, ';')) {
        return (ParseRes) {
            .success = 
# 2272 "src/parser.c" 3 4
                      0
# 2272 "src/parser.c"
                           ,
            .failMessage = "Expected a ; after a normal struct declaration"
        };
    }

    return (ParseRes) { .success = 
# 2277 "src/parser.c" 3 4
                                  1 
# 2277 "src/parser.c"
                                       };
}

ParseRes parseStructOrUnionSpecifier(TokenList *tokens, StructOrUnionSpecifier *structOrUnion) {
    if (consumeIfTok(tokens, Token_struct)) {
        structOrUnion->structOrUnion = StructOrUnion_Struct;
    }
    else if (consumeIfTok(tokens, Token_union)) {
        structOrUnion->structOrUnion = StructOrUnion_Union;
    }
    else {
        return (ParseRes) {
            .success = 
# 2289 "src/parser.c" 3 4
                      0
# 2289 "src/parser.c"
                           ,
            .failMessage = "Expected struct or union keywords for struct or union specifier"
        };
    }

    if (peekTok(tokens).type == Token_Ident) {
        Token tok = consumeTok(tokens);
        structOrUnion->hasIdent = 
# 2296 "src/parser.c" 3 4
                                 1
# 2296 "src/parser.c"
                                     ;
        structOrUnion->ident = tok.ident;
    }

    if (consumeIfTok(tokens, '{')) {
        while (peekTok(tokens).type != '}') {
            StructDeclaration decl = {0};
            ParseRes declRes = parseStructDeclaration(tokens, &decl);
            if (!declRes.success)
                return declRes;

            sll_append(&(structOrUnion->structDeclarations), &decl, sizeof(decl));
        }

        if (!consumeIfTok(tokens, '}')) {
            return (ParseRes) {
                .success = 
# 2312 "src/parser.c" 3 4
                          0
# 2312 "src/parser.c"
                               ,
                .failMessage = "Expected } after struct declaration list"
            };
        }

        return (ParseRes){ .success = 
# 2317 "src/parser.c" 3 4
                                     1 
# 2317 "src/parser.c"
                                          };
    }

    return (ParseRes){ .success = 
# 2320 "src/parser.c" 3 4
                                 1 
# 2320 "src/parser.c"
                                      };
}

ParseRes parseEnumerator(TokenList *tokens, Enumerator *enumerator) {
    if (peekTok(tokens).type != Token_Ident) {
        return (ParseRes) {
            .success = 
# 2326 "src/parser.c" 3 4
                      0
# 2326 "src/parser.c"
                           ,
            .failMessage = "Expected identifier when parsing an enumerator"
        };
    }


    Token tok = consumeTok(tokens);
    enumerator->constantIdent = tok.ident;

    if (consumeIfTok(tokens, '=')) {
        ConditionalExpr constant = {0};
        ParseRes constantRes = parseConditionalExpr(tokens, &constant);
        if (!constantRes.success)
            return constantRes;

        enumerator->hasConstExpr = 
# 2341 "src/parser.c" 3 4
                                  1
# 2341 "src/parser.c"
                                      ;
        enumerator->constantExpr = constant;
    }

    return (ParseRes){ .success = 
# 2345 "src/parser.c" 3 4
                                 1 
# 2345 "src/parser.c"
                                      };
}

ParseRes parseEnumeratorList(TokenList *tokens, EnumeratorList *list) {
    
# 2349 "src/parser.c" 3 4
   _Bool 
# 2349 "src/parser.c"
        foundEndBlock = 
# 2349 "src/parser.c" 3 4
                        0
# 2349 "src/parser.c"
                             ;
    
# 2350 "src/parser.c" 3 4
   _Bool 
# 2350 "src/parser.c"
        hasComma = 
# 2350 "src/parser.c" 3 4
                   0
# 2350 "src/parser.c"
                        ;
    do {

        Enumerator enumerator = {0};
        ParseRes enumRes = parseEnumerator(tokens, &enumerator);
        if (!enumRes.success)
            return enumRes;

        hasComma = consumeIfTok(tokens, ',');

        sll_append(&(list->list), &enumerator, sizeof(enumerator));

        foundEndBlock = peekTok(tokens).type == '}';

    } while(hasComma && !foundEndBlock);

    return (ParseRes){ .success = 
# 2366 "src/parser.c" 3 4
                                 1 
# 2366 "src/parser.c"
                                      };
}

ParseRes parseEnumSpecifier(TokenList *tokens, EnumSpecifier *enumSpecifier) {
    if (!consumeIfTok(tokens, Token_enum)) {
        return (ParseRes) {
            .success = 
# 2372 "src/parser.c" 3 4
                      0
# 2372 "src/parser.c"
                           ,
            .failMessage = "Expected enum token to start enum specifier"
        };
    }

    if (peekTok(tokens).type == Token_Ident) {
        Token tok = consumeTok(tokens);
        enumSpecifier->hasIdent = 
# 2379 "src/parser.c" 3 4
                                 1
# 2379 "src/parser.c"
                                     ;
        enumSpecifier->ident = tok.ident;
    }

    if (consumeIfTok(tokens, '{')) {
        EnumeratorList enumList = {0};
        ParseRes listRes = parseEnumeratorList(tokens, &enumList);
        if (!listRes.success)
            return listRes;

        if (!consumeIfTok(tokens, '}')) {
            return (ParseRes) {
                .success = 
# 2391 "src/parser.c" 3 4
                          0
# 2391 "src/parser.c"
                               ,
                .failMessage = "Expected } after parsing enumerator list"
            };
        }

        enumSpecifier->hasEnumeratorList = 
# 2396 "src/parser.c" 3 4
                                          1
# 2396 "src/parser.c"
                                              ;
        enumSpecifier->enumeratorList = enumList;
    }

    return (ParseRes){ .success = 
# 2400 "src/parser.c" 3 4
                                 1 
# 2400 "src/parser.c"
                                      };
}

ParseRes parseTypeSpecifier(TokenList *tokens, TypeSpecifier *type) {
    ParseRes pass = { .success = 
# 2404 "src/parser.c" 3 4
                                1 
# 2404 "src/parser.c"
                                     };
    ParseRes fail = {
        .success = 
# 2406 "src/parser.c" 3 4
                  0
# 2406 "src/parser.c"
                       ,
        .failMessage = "Couldn't parse type specifier"
    };

    if (consumeIfTok(tokens, Token_void)) {
        type->type = TypeSpecifier_Void;
        return pass;
    }
    if (consumeIfTok(tokens, Token_char)) {
        type->type = TypeSpecifier_Char;
        return pass;
    }
    if (consumeIfTok(tokens, Token_short)) {
        type->type = TypeSpecifier_Short;
        return pass;
    }
    if (consumeIfTok(tokens, Token_int)) {
        type->type = TypeSpecifier_Int;
        return pass;
    }
    if (consumeIfTok(tokens, Token_long)) {
        type->type = TypeSpecifier_Long;
        return pass;
    }
    if (consumeIfTok(tokens, Token_float)) {
        type->type = TypeSpecifier_Float;
        return pass;
    }
    if (consumeIfTok(tokens, Token_double)) {
        type->type = TypeSpecifier_Double;
        return pass;
    }
    if (consumeIfTok(tokens, Token_signed)) {
        type->type = TypeSpecifier_Signed;
        return pass;
    }
    if (consumeIfTok(tokens, Token_unsigned)) {
        type->type = TypeSpecifier_Unsigned;
        return pass;
    }
    if (consumeIfTok(tokens, Token_bool)) {
        type->type = TypeSpecifier_Bool;
        return pass;
    }
    if (consumeIfTok(tokens, Token_complex)) {
        type->type = TypeSpecifier_Complex;
        return pass;
    }
    if (consumeIfTok(tokens, Token_imaginary)) {
        type->type = TypeSpecifier_Imaginary;
        return pass;
    }


    size_t pos = tokens->pos;
    {
        if (!consumeIfTok(tokens, Token_atomic))
            goto PostAtomicType;

        if (!consumeIfTok(tokens, '('))
            goto PostAtomicType;

        TypeName atomicTypeName = {0};
        if (!parseTypeName(tokens, &atomicTypeName).success)
            goto PostAtomicType;

        if (!consumeIfTok(tokens, ')'))
            goto PostAtomicType;


        type->type = TypeSpecifier_AtomicType;
        type->atomicName = atomicTypeName;
        return pass;
    }

PostAtomicType:
    tokens->pos = pos;


    StructOrUnionSpecifier structOrUnion = {0};
    ParseRes structOrUnionRes = parseStructOrUnionSpecifier(tokens, &structOrUnion);
    if (structOrUnionRes.success) {
        type->type = TypeSpecifier_StructOrUnion;
        type->structOrUnion = structOrUnion;
        return pass;
    }

    tokens->pos = pos;


    EnumSpecifier enumSpecifier = {0};
    ParseRes enumRes = parseEnumSpecifier(tokens, &enumSpecifier);
    if (enumRes.success) {
        type->type = TypeSpecifier_Enum;
        type->enumSpecifier = enumSpecifier;
        return pass;
    }

    tokens->pos = pos;


    if (peekTok(tokens).type == Token_Ident) {
        Token tok = consumeTok(tokens);
        if (typedefTable_find(g_typedefTable, tok.ident)) {
            type->type = TypeSpecifier_TypedefName;
            type->typedefName = tok.ident;
            return pass;
        }
    }

    tokens->pos = pos;

    return fail;
}

ParseRes parseFunctionSpecifier(TokenList *tokens, FunctionSpecifier *funcSpecifier) {
    if (consumeIfTok(tokens, Token_inline)) {
        *funcSpecifier = FunctionSpecifier_Inline;
        return (ParseRes){ .success = 
# 2524 "src/parser.c" 3 4
                                     1 
# 2524 "src/parser.c"
                                          };
    }
    if (consumeIfTok(tokens, Token_noreturn)) {
        *funcSpecifier = FunctionSpecifier_Noreturn;
        return (ParseRes){ .success = 
# 2528 "src/parser.c" 3 4
                                     1 
# 2528 "src/parser.c"
                                          };
    }

    return (ParseRes) {
        .success = 
# 2532 "src/parser.c" 3 4
                  0
# 2532 "src/parser.c"
                       ,
        .failMessage = "Expected inline or noreturn for function specifier"
    };
}

ParseRes parseAlignmentSpecifier(TokenList *tokens, AlignmentSpecifier *alignment) {
    if (!consumeIfTok(tokens, Token_alignas)) {
        return (ParseRes) {
            .success = 
# 2540 "src/parser.c" 3 4
                      0
# 2540 "src/parser.c"
                           ,
            .failMessage = "Alignment specifier expected an alignas keyword"
        };
    }

    if (!consumeIfTok(tokens, '(')) {
        return (ParseRes) {
            .success = 
# 2547 "src/parser.c" 3 4
                      0
# 2547 "src/parser.c"
                           ,
            .failMessage = "Alignment specifier requires a ( after alignas"
        };
    }

    size_t pos = tokens->pos;

    TypeName typeName = {0};
    if (parseTypeName(tokens, &typeName).success) {
        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 2558 "src/parser.c" 3 4
                          0
# 2558 "src/parser.c"
                               ,
                .failMessage = "Alignment specifier requires a ) after type name"
            };
        }

        alignment->type = AlignmentSpecifier_TypeName;
        alignment->typeName = typeName;
        return (ParseRes){ .success = 
# 2565 "src/parser.c" 3 4
                                     1 
# 2565 "src/parser.c"
                                          };
    }

    tokens->pos = pos;

    ConditionalExpr expr = {0};
    if (parseConditionalExpr(tokens, &expr).success) {
        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 2574 "src/parser.c" 3 4
                          0
# 2574 "src/parser.c"
                               ,
                .failMessage = "Alignment specifier requires a ) after constant expr"
            };
        }

        alignment->type = AlignmentSpecifier_Constant;
        alignment->constant = expr;
    }

    return (ParseRes){
        .success = 
# 2584 "src/parser.c" 3 4
                  0
# 2584 "src/parser.c"
                       ,
        .failMessage = "Alignment specifier need a constant expr or type name"
    };
}

ParseRes parseDeclarationSpecifier(TokenList *tokens,
    DeclarationSpecifier *outSpec)
{
    size_t pos = tokens->pos;


    StorageClassSpecifier storageClass = {0};
    ParseRes storageClassRes = parseStorageClassSpecifier(tokens, &storageClass);
    if (storageClassRes.success) {
        outSpec->type = DeclarationSpecifier_StorageClass;
        outSpec->storageClass = storageClass;
        return (ParseRes){ .success = 
# 2600 "src/parser.c" 3 4
                                     1 
# 2600 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    TypeSpecifier type = {0};
    ParseRes typeRes = parseTypeSpecifier(tokens, &type);
    if (typeRes.success) {
        outSpec->type = DeclarationSpecifier_Type;
        outSpec->typeSpecifier = type;
        return (ParseRes){ .success = 
# 2611 "src/parser.c" 3 4
                                     1 
# 2611 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    TypeQualifier qualifier = {0};
    ParseRes qualifierRes = parseTypeQualifier(tokens, &qualifier);
    if (qualifierRes.success) {
        outSpec->type = DeclarationSpecifier_TypeQualifier;
        outSpec->typeQualifier = qualifier;
        return (ParseRes){ .success = 
# 2622 "src/parser.c" 3 4
                                     1 
# 2622 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    FunctionSpecifier funcSpecifier = {0};
    ParseRes funcSpecRes = parseFunctionSpecifier(tokens, &funcSpecifier);
    if (funcSpecRes.success) {
        outSpec->type = DeclarationSpecifier_Func;
        outSpec->function = funcSpecifier;
        return (ParseRes){ .success = 
# 2633 "src/parser.c" 3 4
                                     1 
# 2633 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    AlignmentSpecifier alignSpec = {0};
    ParseRes alignRes = parseAlignmentSpecifier(tokens, &alignSpec);
    if (alignRes.success) {
        outSpec->type = DeclarationSpecifier_Alignment;
        outSpec->alignment = alignSpec;
        return (ParseRes){ .success = 
# 2644 "src/parser.c" 3 4
                                     1 
# 2644 "src/parser.c"
                                          };
    }

    return (ParseRes) {
        .success = 
# 2648 "src/parser.c" 3 4
                  0
# 2648 "src/parser.c"
                       ,
        .failMessage = "Couldn't parse declaration specifier"
    };
}

ParseRes parseDeclarationSpecifierList(TokenList *tokens,
    DeclarationSpecifierList *outList)
{

    DeclarationSpecifier specifier = {0};
    ParseRes res = parseDeclarationSpecifier(tokens, &specifier);
    if (!res.success) {
        return res;
    }

    do {
        sll_append(&(outList->list), &specifier, sizeof(specifier));
        res = parseDeclarationSpecifier(tokens, &specifier);
    } while (res.success);

    return (ParseRes) { .success = 
# 2668 "src/parser.c" 3 4
                                  1 
# 2668 "src/parser.c"
                                       };
}

ParseRes parseInitDeclarator(TokenList *tokens, InitDeclarator *initDeclarator) {
    Declarator decl = {0};
    ParseRes declaratorRes = parseDeclarator(tokens, &decl);
    if (!declaratorRes.success)
        return declaratorRes;

    initDeclarator->decl = decl;

    if (consumeIfTok(tokens, '=')) {
        Initializer init = {0};
        ParseRes initRes = parseInitializer(tokens, &init);
        if (!initRes.success)
            return initRes;

        initDeclarator->hasInitializer = 
# 2685 "src/parser.c" 3 4
                                        1
# 2685 "src/parser.c"
                                            ;
        initDeclarator->initializer = init;
    }

    return (ParseRes) { .success = 
# 2689 "src/parser.c" 3 4
                                  1 
# 2689 "src/parser.c"
                                       };
}

ParseRes parseInitDeclaratorList(TokenList *tokens, InitDeclaratorList *initList) {
    
# 2693 "src/parser.c" 3 4
   _Bool 
# 2693 "src/parser.c"
        hasComma = 
# 2693 "src/parser.c" 3 4
                   0
# 2693 "src/parser.c"
                        ;
    do {

        size_t pos = tokens->pos;


        InitDeclarator decl = {0};
        ParseRes declRes = parseInitDeclarator(tokens, &decl);
        if (!declRes.success) {
            tokens->pos = pos;
            break;
        }




        if (consumeIfTok(tokens, Token_asm)) {

            if (!consumeIfTok(tokens, '(')) {
                return (ParseRes) {
                    .success = 
# 2713 "src/parser.c" 3 4
                              0
# 2713 "src/parser.c"
                                   ,
                    .failMessage = "Expected ( after asm in declaration rename"
                };
            }


            if (!consumeIfTok(tokens, Token_ConstString)) {
                return (ParseRes) {
                    .success = 
# 2721 "src/parser.c" 3 4
                              0
# 2721 "src/parser.c"
                                   ,
                    .failMessage = "Expected String after 'asm (' in declaration rename"
                };
            }



            while (peekTok(tokens).type == Token_ConstString)
                consumeTok(tokens);


            if (!consumeIfTok(tokens, ')')) {
                return (ParseRes) {
                    .success = 
# 2734 "src/parser.c" 3 4
                              0
# 2734 "src/parser.c"
                                   ,
                    .failMessage = "Expected ) after 'asm ( String' in declaration rename"
                };
            }
        }

        sll_append(&(initList->list), &decl, sizeof(decl));


        hasComma = consumeIfTok(tokens, ',');

    } while (hasComma);


    if (initList->list.size == 0) {
        return (ParseRes) {
            .success = 
# 2750 "src/parser.c" 3 4
                      0
# 2750 "src/parser.c"
                           ,
            .failMessage = "Expected init declarators in init declarator list"
        };
    }

    return (ParseRes){ .success = 
# 2755 "src/parser.c" 3 4
                                 1 
# 2755 "src/parser.c"
                                      };
}

String directDeclarator_getName(DirectDeclarator decl) {
    if (decl.type == DirectDeclarator_Ident)
        return decl.ident;
    else
        return directDeclarator_getName(decl.declarator->directDeclarator);
}

ParseRes parseDeclaration(TokenList *tokens, Declaration *outDef) {

    if (peekTok(tokens).type == Token_staticAssert) {
        StaticAssertDeclaration staticDecl = {0};
        ParseRes staticRes = parseStaticAssertDeclaration(tokens, &staticDecl);
        if (!staticRes.success)
            return staticRes;

        outDef->type = Declaration_StaticAssert;
        outDef->staticAssert = staticDecl;
        return (ParseRes){ .success = 
# 2775 "src/parser.c" 3 4
                                     1 
# 2775 "src/parser.c"
                                          };
    }


    DeclarationSpecifierList specifiers = {0};
    ParseRes listRes = parseDeclarationSpecifierList(tokens, &specifiers);
    if (!listRes.success)
        return listRes;

    outDef->type = Declaration_Normal;
    outDef->declSpecifiers = specifiers;


    size_t pos = tokens->pos;

    InitDeclaratorList initList = {0};
    ParseRes initRes = parseInitDeclaratorList(tokens, &initList);
    if (initRes.success) {
        outDef->hasInitDeclaratorList = 
# 2793 "src/parser.c" 3 4
                                       1
# 2793 "src/parser.c"
                                           ;
        outDef->initDeclaratorList = initList;
    }
    else {
        outDef->hasInitDeclaratorList = 
# 2797 "src/parser.c" 3 4
                                       0
# 2797 "src/parser.c"
                                            ;
        tokens->pos = pos;
    }


    if (!consumeIfTok(tokens, ';')) {
        return (ParseRes) {
            .success = 
# 2804 "src/parser.c" 3 4
                      0
# 2804 "src/parser.c"
                           ,
            .failMessage = "Expected semicolon after declaration"
        };
    }



    if (specifiers.list.size == 0)
        goto Post_Typedef_Ident;

    DeclarationSpecifier *declSpec = slNode_getData(specifiers.list.head);
    if (declSpec->type != DeclarationSpecifier_StorageClass)
        goto Post_Typedef_Ident;

    if (declSpec->storageClass != StorageClass_Typedef)
        goto Post_Typedef_Ident;


    for (SLNode *node = initList.list.head; node != 
# 2822 "src/parser.c" 3 4
   ((void *)0)
# 2822 "src/parser.c"
   ; node = node->next) {
        InitDeclarator *decl = slNode_getData(node);
        String name = directDeclarator_getName(decl->decl.directDeclarator);
        if (name.length > 0) {
            typedefTable_add(&g_typedefTable, name);
        }
    }

Post_Typedef_Ident:

    return (ParseRes){ .success = 
# 2832 "src/parser.c" 3 4
                                 1 
# 2832 "src/parser.c"
                                      };
}

ParseRes parseLabeledStatement(TokenList *tokens, LabeledStatement *stmt) {
    if (peekTok(tokens).type == Token_Ident) {
        Token tok = consumeTok(tokens);

        if (!consumeIfTok(tokens, ':')) {
            return (ParseRes) {
                .success = 
# 2841 "src/parser.c" 3 4
                          0
# 2841 "src/parser.c"
                               ,
                .failMessage = "Expected : after label identifier"
            };
        }

        stmt->type = LabeledStatement_Ident;
        stmt->ident = tok.ident;
    }
    else if (consumeIfTok(tokens, Token_case)) {
        ConditionalExpr constant = {0};
        ParseRes constRes = parseConditionalExpr(tokens, &constant);
        if (!constRes.success) {
            return constRes;
        }

        if (!consumeIfTok(tokens, ':')) {
            return (ParseRes) {
                .success = 
# 2858 "src/parser.c" 3 4
                          0
# 2858 "src/parser.c"
                               ,
                .failMessage = "Expected : after case label"
            };
        }

        stmt->type = LabeledStatement_Case;
        stmt->caseConstExpr = constant;
    }
    else if (consumeIfTok(tokens, Token_default)) {
        if (!consumeIfTok(tokens, ':')) {
            return (ParseRes) {
                .success = 
# 2869 "src/parser.c" 3 4
                          0
# 2869 "src/parser.c"
                               ,
                .failMessage = "Expected : after case label"
            };
        }

        stmt->type = LabeledStatement_Default;
    }
    else {
        return (ParseRes) {
            .success = 
# 2878 "src/parser.c" 3 4
                      0
# 2878 "src/parser.c"
                           ,
            .failMessage = "Expected ident, case, or default for a labeled statment"
        };
    }

    Statement inner = {0};
    ParseRes res = parseStatement(tokens, &inner);
    if (!res.success)
        return res;

    stmt->stmt = malloc(sizeof(inner));
    memcpy(stmt->stmt, &inner, sizeof(inner));
    return (ParseRes){ .success = 
# 2890 "src/parser.c" 3 4
                                 1 
# 2890 "src/parser.c"
                                      };
}

ParseRes parseSelectionStatement(TokenList *tokens, SelectionStatement *selection) {
    if (consumeIfTok(tokens, Token_if)) {
        selection->ifToken = tokens->tokens + tokens->pos - 1;

        if (!consumeIfTok(tokens, '(')) {
            return (ParseRes) {
                .success = 
# 2899 "src/parser.c" 3 4
                          0
# 2899 "src/parser.c"
                               ,
                .failMessage = "Expected ( after if"
            };
        }

        Expr expr = {0};
        ParseRes exprRes = parseExpr(tokens, &expr);
        if (!exprRes.success)
            return exprRes;

        selection->type = SelectionStatement_If;
        selection->ifExpr = expr;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 2914 "src/parser.c" 3 4
                          0
# 2914 "src/parser.c"
                               ,
                .failMessage = "Expected ) after expr in if statement"
            };
        }

        Statement stmt = {0};
        ParseRes stmtRes = parseStatement(tokens, &stmt);
        if (!stmtRes.success)
            return stmtRes;

        selection->ifTrueStmt = malloc(sizeof(stmt));
        memcpy(selection->ifTrueStmt, &stmt, sizeof(stmt));

        if (consumeIfTok(tokens, Token_else)) {
            selection->elseToken = tokens->tokens + tokens->pos - 1;

            Statement elseStmt = {0};

            ParseRes elseStmtRes = parseStatement(tokens, &elseStmt);
            if (!elseStmtRes.success)
                return elseStmtRes;

            selection->ifHasElse = 
# 2936 "src/parser.c" 3 4
                                  1
# 2936 "src/parser.c"
                                      ;
            selection->ifFalseStmt = malloc(sizeof(elseStmt));
            memcpy(selection->ifFalseStmt, &elseStmt, sizeof(elseStmt));
        }

        return (ParseRes){ .success = 
# 2941 "src/parser.c" 3 4
                                     1 
# 2941 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, Token_switch)) {
        selection->switchToken = tokens->tokens + tokens->pos - 1;

        if (!consumeIfTok(tokens, '(')) {
            return (ParseRes) {
                .success = 
# 2948 "src/parser.c" 3 4
                          0
# 2948 "src/parser.c"
                               ,
                .failMessage = "Expected ( after switch"
            };
        }

        Expr expr = {0};
        ParseRes exprRes = parseExpr(tokens, &expr);
        if (!exprRes.success)
            return exprRes;

        selection->type = SelectionStatement_Switch;
        selection->switchExpr = expr;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 2963 "src/parser.c" 3 4
                          0
# 2963 "src/parser.c"
                               ,
                .failMessage = "Expected ) after expr in switch statement"
            };
        }

        Statement stmt = {0};
        ParseRes stmtRes = parseStatement(tokens, &stmt);
        if (!stmtRes.success)
            return stmtRes;

        selection->switchStmt = malloc(sizeof(stmt));
        memcpy(selection->switchStmt, &stmt, sizeof(stmt));

        return (ParseRes){ .success = 
# 2976 "src/parser.c" 3 4
                                     1 
# 2976 "src/parser.c"
                                          };
    }
    else {
        return (ParseRes) {
            .success = 
# 2980 "src/parser.c" 3 4
                      0
# 2980 "src/parser.c"
                           ,
            .failMessage = "Expected if or switch for selection statement"
        };
    }
}

ParseRes parseExpressionStatement(TokenList *tokens, ExpressionStatement *expression) {
    if (consumeIfTok(tokens, ';')) {
        expression->isEmpty = 
# 2988 "src/parser.c" 3 4
                             1
# 2988 "src/parser.c"
                                 ;
        return (ParseRes){ .success = 
# 2989 "src/parser.c" 3 4
                                     1 
# 2989 "src/parser.c"
                                          };
    }

    Expr expr = {0};
    ParseRes exprRes = parseExpr(tokens, &expr);
    if (!exprRes.success)
        return exprRes;

    if (!consumeIfTok(tokens, ';')) {
        return (ParseRes) {
            .success = 
# 2999 "src/parser.c" 3 4
                      0
# 2999 "src/parser.c"
                           ,
            .failMessage = "Expected ; after expr in expression stmt"
        };
    }

    expression->isEmpty = 
# 3004 "src/parser.c" 3 4
                         0
# 3004 "src/parser.c"
                              ;
    expression->expr = expr;

    return (ParseRes){ .success = 
# 3007 "src/parser.c" 3 4
                                 1 
# 3007 "src/parser.c"
                                      };
}

ParseRes parseIterationStatement(TokenList *tokens, IterationStatement *iteration) {

    if (consumeIfTok(tokens, Token_while)) {
        iteration->whileToken = tokens->tokens + tokens->pos - 1;

        if (!consumeIfTok(tokens, '(')) {
            return (ParseRes) {
                .success = 
# 3017 "src/parser.c" 3 4
                          0
# 3017 "src/parser.c"
                               ,
                .failMessage = "Expected ( after while"
            };
        }

        Expr expr = {0};
        ParseRes exprRes = parseExpr(tokens, &expr);
        if (!exprRes.success)
            return exprRes;

        iteration->type = IterationStatement_While;
        iteration->whileExpr = expr;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 3032 "src/parser.c" 3 4
                          0
# 3032 "src/parser.c"
                               ,
                .failMessage = "Expected ) after expr in while stmt"
            };
        }

        Statement stmt = {0};
        ParseRes stmtRes = parseStatement(tokens, &stmt);
        if (!stmtRes.success)
            return stmtRes;

        iteration->whileStmt = malloc(sizeof(stmt));
        memcpy(iteration->whileStmt, &stmt, sizeof(stmt));

        return (ParseRes){ .success = 
# 3045 "src/parser.c" 3 4
                                     1 
# 3045 "src/parser.c"
                                          };
    }


    else if (consumeIfTok(tokens, Token_do)) {
        iteration->doToken = tokens->tokens + tokens->pos - 1;

        Statement stmt = {0};
        ParseRes stmtRes = parseStatement(tokens, &stmt);
        if (!stmtRes.success)
            return stmtRes;

        iteration->type = IterationStatement_DoWhile;
        iteration->doStmt = malloc(sizeof(stmt));
        memcpy(iteration->doStmt, &stmt, sizeof(stmt));

        if (!consumeIfTok(tokens, Token_while)) {
            return (ParseRes) {
                .success = 
# 3063 "src/parser.c" 3 4
                          0
# 3063 "src/parser.c"
                               ,
                .failMessage = "Expected while after do statement"
            };
        }

        if (!consumeIfTok(tokens, '(')) {
            return (ParseRes) {
                .success = 
# 3070 "src/parser.c" 3 4
                          0
# 3070 "src/parser.c"
                               ,
                .failMessage = "Expected ( after while in do while stmt"
            };
        }

        Expr expr = {0};
        ParseRes exprRes = parseExpr(tokens, &expr);
        if (!exprRes.success)
            return exprRes;

        iteration->doExpr = expr;

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 3084 "src/parser.c" 3 4
                          0
# 3084 "src/parser.c"
                               ,
                .failMessage = "Expected ) after expr in do while stmt"
            };
        }

        if (!consumeIfTok(tokens, ';')) {
            return (ParseRes) {
                .success = 
# 3091 "src/parser.c" 3 4
                          0
# 3091 "src/parser.c"
                               ,
                .failMessage = "Expected ; after ) in do while stmt"
            };
        }

        return (ParseRes){ .success = 
# 3096 "src/parser.c" 3 4
                                     1 
# 3096 "src/parser.c"
                                          };
    }


    else if (consumeIfTok(tokens, Token_for)) {
        iteration->forToken = tokens->tokens + tokens->pos - 1;

        if (!consumeIfTok(tokens, '(')) {
            return (ParseRes) {
                .success = 
# 3105 "src/parser.c" 3 4
                          0
# 3105 "src/parser.c"
                               ,
                .failMessage = "Expected ( after for in for stmt"
            };
        }

        iteration->type = IterationStatement_For;

        size_t pos = tokens->pos;


        Declaration decl = {0};
        ParseRes declRes = parseDeclaration(tokens, &decl);
        if (declRes.success) {
            iteration->forHasInitialDeclaration = 
# 3118 "src/parser.c" 3 4
                                                 1
# 3118 "src/parser.c"
                                                     ;
            iteration->forInitialDeclaration = decl;
        }
        else {
            tokens->pos = pos;

            iteration->forHasInitialDeclaration = 
# 3124 "src/parser.c" 3 4
                                                 0
# 3124 "src/parser.c"
                                                      ;

            ExpressionStatement exprStmt = {0};
            ParseRes exprStmtRes = parseExpressionStatement(tokens, &exprStmt);
            if (!exprStmtRes.success)
                return exprStmtRes;

            iteration->forInitialExprStmt = exprStmt;
        }

        ExpressionStatement innerExprStmt = {0};
        ParseRes innerExprRes = parseExpressionStatement(tokens, &innerExprStmt);
        if (!innerExprRes.success)
            return innerExprRes;

        iteration->forInnerExprStmt = innerExprStmt;

        size_t preExprPos = tokens->pos;

        Expr expr = {0};
        ParseRes exprRes = parseExpr(tokens, &expr);
        if (exprRes.success) {
            iteration->forHasFinalExpr = 
# 3146 "src/parser.c" 3 4
                                        1
# 3146 "src/parser.c"
                                            ;
            iteration->forFinalExpr = expr;
        }
        else {
            tokens->pos = preExprPos;
        }

        if (!consumeIfTok(tokens, ')')) {
            return (ParseRes) {
                .success = 
# 3155 "src/parser.c" 3 4
                          0
# 3155 "src/parser.c"
                               ,
                .failMessage = "Expected ) after expressions in for stmt"
            };
        }

        Statement stmt = {0};
        ParseRes stmtRes = parseStatement(tokens, &stmt);
        if (!stmtRes.success)
            return stmtRes;

        iteration->forStmt = malloc(sizeof(stmt));
        memcpy(iteration->forStmt, &stmt, sizeof(stmt));

        return (ParseRes){ .success = 
# 3168 "src/parser.c" 3 4
                                     1 
# 3168 "src/parser.c"
                                          };
    }

    else {
        return (ParseRes) {
            .success = 
# 3173 "src/parser.c" 3 4
                      0
# 3173 "src/parser.c"
                           ,
            .failMessage = "Expected while, do, or for in iteration statement"
        };
    }
}

ParseRes parseJumpStatement(TokenList *tokens, JumpStatement *jump) {
    if (consumeIfTok(tokens, Token_goto)) {
        Token tok = consumeTok(tokens);
        if (tok.type != Token_Ident) {
            return (ParseRes) {
                .success = 
# 3184 "src/parser.c" 3 4
                          0
# 3184 "src/parser.c"
                               ,
                .failMessage = "Expected identifier after goto"
            };
        }

        if (!consumeIfTok(tokens, ';')) {
            return (ParseRes) {
                .success = 
# 3191 "src/parser.c" 3 4
                          0
# 3191 "src/parser.c"
                               ,
                .failMessage = "Expected ; after goto identifier"
            };
        }

        jump->type = JumpStatement_Goto;
        jump->gotoIdent = tok.ident;
        return (ParseRes){ .success = 
# 3198 "src/parser.c" 3 4
                                     1 
# 3198 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, Token_continue)) {
        if (!consumeIfTok(tokens, ';')) {
            return (ParseRes) {
                .success = 
# 3203 "src/parser.c" 3 4
                          0
# 3203 "src/parser.c"
                               ,
                .failMessage = "Expected ; after continue"
            };
        }

        jump->type = JumpStatement_Continue;
        return (ParseRes){ .success = 
# 3209 "src/parser.c" 3 4
                                     1 
# 3209 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, Token_break)) {
        if (!consumeIfTok(tokens, ';')) {
            return (ParseRes) {
                .success = 
# 3214 "src/parser.c" 3 4
                          0
# 3214 "src/parser.c"
                               ,
                .failMessage = "Expected ; after break"
            };
        }

        jump->type = JumpStatement_Break;
        return (ParseRes){ .success = 
# 3220 "src/parser.c" 3 4
                                     1 
# 3220 "src/parser.c"
                                          };
    }
    else if (consumeIfTok(tokens, Token_return)) {
        jump->type = JumpStatement_Return;

        if (consumeIfTok(tokens, ';')) {
            jump->returnHasExpr = 
# 3226 "src/parser.c" 3 4
                                 0
# 3226 "src/parser.c"
                                      ;
            return (ParseRes){ .success = 
# 3227 "src/parser.c" 3 4
                                         1 
# 3227 "src/parser.c"
                                              };
        }

        Expr expr = {0};
        ParseRes exprRes = parseExpr(tokens, &expr);
        if (!exprRes.success)
            return exprRes;

        if (!consumeIfTok(tokens, ';')) {
            return (ParseRes) {
                .success = 
# 3237 "src/parser.c" 3 4
                          0
# 3237 "src/parser.c"
                               ,
                .failMessage = "Expected ; after return expr"
            };
        }

        jump->returnHasExpr = 
# 3242 "src/parser.c" 3 4
                             1
# 3242 "src/parser.c"
                                 ;
        jump->returnExpr = expr;

        return (ParseRes){ .success = 
# 3245 "src/parser.c" 3 4
                                     1 
# 3245 "src/parser.c"
                                          };
    }
    else {
        return (ParseRes) {
            .success = 
# 3249 "src/parser.c" 3 4
                      0
# 3249 "src/parser.c"
                           ,
            .failMessage = "Expected goto, continue, break, or return in jump statement"
        };
    }
}

ParseRes parseAsmStatement(TokenList *tokens, AsmStatement *stmt) {
    if (consumeTok(tokens).type != Token_asm)
        return ((ParseRes){ .success = 
# 3257 "src/parser.c" 3 4
              0
# 3257 "src/parser.c"
              , .failMessage = "Expected asm at beginning of asm statement" });

    while (peekTok(tokens).type == Token_volatile ||
           peekTok(tokens).type == Token_inline ||
           peekTok(tokens).type == Token_goto)
    {
        consumeTok(tokens);
    }

    if (consumeTok(tokens).type != '(') {
        return ((ParseRes){ .success = 
# 3267 "src/parser.c" 3 4
              0
# 3267 "src/parser.c"
              , .failMessage = "Expected ( after asm token in asm statement" });
    }

    uint64_t numParens = 0;

    while (peekTok(tokens).type != ')' || (numParens != 0)) {
        if (peekTok(tokens).type == '(') {
            numParens++;
        }
        else if (peekTok(tokens).type == ')') {
            numParens--;
        }
        consumeTok(tokens);
    }

    
# 3282 "src/parser.c" 3 4
   ((void) sizeof ((
# 3282 "src/parser.c"
   consumeTok(tokens).type == ')'
# 3282 "src/parser.c" 3 4
   ) ? 1 : 0), __extension__ ({ if (
# 3282 "src/parser.c"
   consumeTok(tokens).type == ')'
# 3282 "src/parser.c" 3 4
   ) ; else __assert_fail (
# 3282 "src/parser.c"
   "consumeTok(tokens).type == ')'"
# 3282 "src/parser.c" 3 4
   , "src/parser.c", 3282, __extension__ __PRETTY_FUNCTION__); }))
# 3282 "src/parser.c"
                                         ;

    if (consumeTok(tokens).type != ';') {
        return ((ParseRes){ .success = 
# 3285 "src/parser.c" 3 4
              0
# 3285 "src/parser.c"
              , .failMessage = "Expected ; after asm statement" });
    }

    return ((ParseRes){ .success = 
# 3288 "src/parser.c" 3 4
          1 
# 3288 "src/parser.c"
          });
}

ParseRes parseStatement(TokenList *tokens, Statement *stmt) {
    size_t pos = tokens->pos;

    LabeledStatement labeled = {0};
    if (parseLabeledStatement(tokens, &labeled).success) {
        stmt->type = Statement_Labeled;
        stmt->labeled = labeled;
        return (ParseRes){ .success = 
# 3298 "src/parser.c" 3 4
                                     1 
# 3298 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    CompoundStmt compound = {0};
    if (parseCompoundStmt(tokens, &compound).success) {
        stmt->type = Statement_Compound;
        stmt->compound = malloc(sizeof(compound));
        memcpy(stmt->compound, &compound, sizeof(compound));
        return (ParseRes){ .success = 
# 3309 "src/parser.c" 3 4
                                     1 
# 3309 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    SelectionStatement selection = {0};
    if (parseSelectionStatement(tokens, &selection).success) {
        stmt->type = Statement_Selection;
        stmt->selection = selection;
        return (ParseRes){ .success = 
# 3319 "src/parser.c" 3 4
                                     1 
# 3319 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    IterationStatement iteration = {0};
    if (parseIterationStatement(tokens, &iteration).success) {
        stmt->type = Statement_Iteration;
        stmt->iteration = iteration;
        return (ParseRes){ .success = 
# 3329 "src/parser.c" 3 4
                                     1 
# 3329 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    JumpStatement jump = {0};
    if (parseJumpStatement(tokens, &jump).success) {
        stmt->type = Statement_Jump;
        stmt->jump = jump;
        return (ParseRes){ .success = 
# 3339 "src/parser.c" 3 4
                                     1 
# 3339 "src/parser.c"
                                          };
    }

    tokens->pos = pos;


    ExpressionStatement expression = {0};
    if (parseExpressionStatement(tokens, &expression).success) {
        stmt->type = Statement_Expression;
        stmt->expression = expression;
        return (ParseRes){ .success = 
# 3349 "src/parser.c" 3 4
                                     1 
# 3349 "src/parser.c"
                                          };
    }



    AsmStatement assembly = {0};
    if (parseAsmStatement(tokens, &assembly).success) {
        stmt->type = Statement_Asm;
        stmt->assembly = assembly;
        return (ParseRes){ .success = 
# 3358 "src/parser.c" 3 4
                                     1 
# 3358 "src/parser.c"
                                          };
    }

    return (ParseRes) {
        .success = 
# 3362 "src/parser.c" 3 4
                  0
# 3362 "src/parser.c"
                       ,
        .failMessage = "Didn't find any statements"
    };
}

ParseRes parseBlockItem(TokenList *tokens, BlockItem *item) {

    size_t pos = tokens->pos;

    Declaration decl = {0};
    if (parseDeclaration(tokens, &decl).success) {
        item->type = BlockItem_Declaration;
        item->decl = decl;
        return (ParseRes){ .success = 
# 3375 "src/parser.c" 3 4
                                     1 
# 3375 "src/parser.c"
                                          };
    }

    tokens->pos = pos;

    Statement stmt = {0};
    if (parseStatement(tokens, &stmt).success) {
        item->type = BlockItem_Statement;
        item->stmt = stmt;
        return (ParseRes){ .success = 
# 3384 "src/parser.c" 3 4
                                     1 
# 3384 "src/parser.c"
                                          };
    }

    return (ParseRes){
        .success = 
# 3388 "src/parser.c" 3 4
                  0
# 3388 "src/parser.c"
                       ,
        .failMessage = "Expected either declaration or stmt in block item"
    };
}

ParseRes parseBlockItemList(TokenList *tokens, BlockItemList *list) {
    ParseRes blockItemRes = {0};
    do {


        size_t pos = tokens->pos;

        BlockItem item = {0};
        blockItemRes = parseBlockItem(tokens, &item);
        if (!blockItemRes.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(&(list->list), &item, sizeof(item));
    } while(blockItemRes.success);


    if (list->list.size == 0) {
        return (ParseRes) {
            .success = 
# 3413 "src/parser.c" 3 4
                      0
# 3413 "src/parser.c"
                           ,
            .failMessage = "Expected at least one block item in a block item list"
        };
    }

    return (ParseRes){ .success = 
# 3418 "src/parser.c" 3 4
                                 1 
# 3418 "src/parser.c"
                                      };
}

ParseRes parseCompoundStmt(TokenList *tokens, CompoundStmt *outStmt) {
    if (!consumeIfTok(tokens, '{')) {
        return (ParseRes) {
            .success = 
# 3424 "src/parser.c" 3 4
                      0
# 3424 "src/parser.c"
                           ,
            .failMessage = "Expected { to start compound statement"
        };
    }



    outStmt->openBracket = tokens->tokens + tokens->pos - 1;

    if (consumeIfTok(tokens, '}')) {

        outStmt->closeBracket = tokens->tokens + tokens->pos - 1;

        outStmt->isEmpty = 
# 3437 "src/parser.c" 3 4
                          1
# 3437 "src/parser.c"
                              ;
        return (ParseRes){ .success = 
# 3438 "src/parser.c" 3 4
                                     1 
# 3438 "src/parser.c"
                                          };
    }

    BlockItemList list = {0};
    ParseRes listRes = parseBlockItemList(tokens, &list);
    if (!listRes.success)
        return listRes;

    if (!consumeIfTok(tokens, '}')) {
        return (ParseRes) {
            .success = 
# 3448 "src/parser.c" 3 4
                      0
# 3448 "src/parser.c"
                           ,
            .failMessage = "Expected } after block item list in compound stmt"
        };
    }


    outStmt->closeBracket = tokens->tokens + tokens->pos - 1;

    outStmt->isEmpty = 
# 3456 "src/parser.c" 3 4
                      0
# 3456 "src/parser.c"
                           ;
    outStmt->blockItemList = list;
    return (ParseRes){ .success = 
# 3458 "src/parser.c" 3 4
                                 1 
# 3458 "src/parser.c"
                                      };
}

ParseRes parseFuncDef(TokenList *tokens, FuncDef *outDef) {
    outDef->startTok = tokens->tokens + tokens->pos;


    DeclarationSpecifierList specifierList = {0};
    ParseRes specifierRes = parseDeclarationSpecifierList(
        tokens, &specifierList);
    if (!specifierRes.success) {
        return specifierRes;
    }
    outDef->specifiers = specifierList;


    Declarator declarator = {0};
    ParseRes declRes = parseDeclarator(tokens, &declarator);
    if (!declRes.success)
        return declRes;

    outDef->declarator = declarator;


    ParseRes listRes = {0};
    do {

        size_t pos = tokens->pos;

        Declaration declaration = {0};
        listRes = parseDeclaration(tokens, &declaration);
        if (!listRes.success) {
            tokens->pos = pos;
            break;
        }

        sll_append(&(outDef->declarations), &declaration, sizeof(declaration));
    } while(listRes.success);


    CompoundStmt stmt = {0};
    ParseRes stmtRes = parseCompoundStmt(tokens, &stmt);
    if (!stmtRes.success)
        return stmtRes;

    outDef->stmt = stmt;

    outDef->endTok = tokens->tokens + tokens->pos - 1;

    return (ParseRes){ .success = 
# 3507 "src/parser.c" 3 4
                                 1 
# 3507 "src/parser.c"
                                      };
}

ParseRes parseExternalDecl(TokenList *tokens, ExternalDecl *outDecl) {

    size_t pos = tokens->pos;
    FuncDef def = {0};
    ParseRes res = parseFuncDef(tokens, &def);
    if (res.success) {
        outDecl->type = ExternalDecl_FuncDef;
        outDecl->func = def;
        return res;
    }
    tokens->pos = pos;


    Declaration decl = {0};
    ParseRes declRes = parseDeclaration(tokens, &decl);
    if (declRes.success) {
        outDecl->type = ExternalDecl_Decl;
        outDecl->decl = decl;
        return (ParseRes){ .success = 
# 3528 "src/parser.c" 3 4
                                     1 
# 3528 "src/parser.c"
                                          };
    }

    return (ParseRes) {
        .success = 
# 3532 "src/parser.c" 3 4
                  0
# 3532 "src/parser.c"
                       ,
        .failMessage = "Couldn't find a function definition or declaration"
    };
}


# 3537 "src/parser.c" 3 4
_Bool 
# 3537 "src/parser.c"
    parseTokens(TokenList *tokens, TranslationUnit *outUnit) {

    typedefTable_add(&g_typedefTable, astr("__builtin_va_list"));
    typedefTable_add(&g_typedefTable, astr("_Float128"));

    tokens->pos = 0;

    while (tokens->pos < tokens->numTokens) {
        size_t pos = tokens->pos;

        ExternalDecl decl = {0};
        ParseRes res = parseExternalDecl(tokens, &decl);
        if (!res.success) {
            tokens->pos = pos;
            Token tok = tokens->tokens[tokens->pos];
            vlog("src/parser.c", 3552, Severity_Error, "Parser: %s:%ld: %s\n  Current token position: %ld\n", tok.fileName, tok.line, res.failMessage, tokens->pos);
            return 
# 3553 "src/parser.c" 3 4
                  0
# 3553 "src/parser.c"
                       ;
        }

        sll_append(&(outUnit->externalDecls), &decl, sizeof(decl));
    }

    return 
# 3559 "src/parser.c" 3 4
          1
# 3559 "src/parser.c"
              ;
}



void printConditionalExpr(ConditionalExpr expr, uint64_t indent);
void printInitializer(Initializer init, uint64_t indent);
void printAssignExpr(AssignExpr expr, uint64_t indent);
void printInitializerList(InitializerList list, uint64_t indent);
void printTypeName(TypeName type, uint64_t indent);
void printExpr(Expr expr, uint64_t indent);
void printCastExpr(CastExpr expr, uint64_t indent);
void printDeclarationSpecifierList(DeclarationSpecifierList list, uint64_t indent);
void printDeclarator(Declarator decl, uint64_t indent);
void printAbstractDeclarator(AbstractDeclarator decl, uint64_t indent);
void printTypeQualifier(TypeQualifier type, uint64_t indent);
void printTypeSpecifier(TypeSpecifier type, uint64_t indent);
void printStatement(Statement stmt, uint64_t indent);
void printCompoundStmt(CompoundStmt stmt, uint64_t indent);

void printIndent(uint64_t indent) {
    for (uint64_t i = 0; i < indent; i++)
        ;
}

void printDesignator(Designator designator, uint64_t indent) {
    if (designator.type == Designator_Constant) {
        printConditionalExpr(*(designator.constantExpr), indent);
    }
    else if (designator.type == Designator_Ident) {
        printIndent(indent);
        ;
    }
}

void printDesignation(Designation desig, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = desig.list.head; node != 
# 3597 "src/parser.c" 3 4
   ((void *)0)
# 3597 "src/parser.c"
   ; node = node->next) {
        Designator *designator = slNode_getData(node);
        printDesignator(*designator, indent + 2);
    }
}

void printInitializer(Initializer init, uint64_t indent) {
    if (init.type == Initializer_InitializerList) {
        printInitializerList(*(init.initializerList), indent);
    }
    else if (init.type == Initializer_Assignment) {
        printAssignExpr(*(init.assignmentExpr), indent);
    }
}

void printDesignationAndInitializer(DesignationAndInitializer desig, uint64_t indent) {
    if (desig.hasDesignation) {
        printDesignation(desig.designation, indent);
    }

    printInitializer(desig.initializer, indent + 2);
}

void printInitializerList(InitializerList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.list.head; node != 
# 3623 "src/parser.c" 3 4
   ((void *)0)
# 3623 "src/parser.c"
   ; node = node->next) {
        DesignationAndInitializer *desig = slNode_getData(node);
        printDesignationAndInitializer(*desig, indent + 2);
    }
}

void printGenericAssociation(GenericAssociation assoc, uint64_t indent) {
    if (assoc.isDefault) {
        printIndent(indent);
        ;
    }
    else {
        printTypeName(*(assoc.typeName), indent);
    }

    printAssignExpr(*(assoc.expr), indent + 2);
}

void printGenericSelection(GenericSelection generic, uint64_t indent) {
    printIndent(indent);
    ;

    printAssignExpr(*(generic.expr), indent + 2);

    printIndent(indent);
    ;
    for (SLNode *node = generic.associations.head; node != 
# 3649 "src/parser.c" 3 4
   ((void *)0)
# 3649 "src/parser.c"
   ; node = node->next) {
        GenericAssociation *assoc = slNode_getData(node);
        printGenericAssociation(*assoc, indent + 2);
    }
}

void printConstantExpr(ConstantExpr expr, uint64_t indent) {
    if (expr.type == Constant_Numeric) {
        printIndent(indent);
        ;
    }
    else if (expr.type == Constant_Character) {
        printIndent(indent);
        ;
    }
    else {
        
# 3665 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3665 "src/parser.c"
       "false"
# 3665 "src/parser.c" 3 4
       , "src/parser.c", 3665, __extension__ __PRETTY_FUNCTION__); }))
# 3665 "src/parser.c"
                    ;
    }
}

void printPrimaryExpr(PrimaryExpr expr, uint64_t indent) {
    if (expr.type == PrimaryExpr_Ident) {
        printIndent(indent);
        ;
    }
    else if (expr.type == PrimaryExpr_Constant) {
        printConstantExpr(expr.constant, indent);
    }
    else if (expr.type == PrimaryExpr_String) {
        printIndent(indent);
        ;
    }
    else if (expr.type == PrimaryExpr_FuncName) {
        printIndent(indent);
        ;
    }
    else if (expr.type == PrimaryExpr_Expr) {
        printIndent(indent);
        ;

        printExpr(*(expr.expr), indent + 2);

        printIndent(indent);
        ;
    }
    else if (expr.type == PrimaryExpr_GenericSelection) {
        printGenericSelection(expr.genericSelection, indent);
    }
    else {
        
# 3698 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3698 "src/parser.c"
       "false"
# 3698 "src/parser.c" 3 4
       , "src/parser.c", 3698, __extension__ __PRETTY_FUNCTION__); }))
# 3698 "src/parser.c"
                    ;
    }
}

void printArgExprList(ArgExprList args, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = args.list.head; node != 
# 3705 "src/parser.c" 3 4
   ((void *)0)
# 3705 "src/parser.c"
   ; node = node->next) {
        AssignExpr *expr = slNode_getData(node);
        printAssignExpr(*expr, indent + 2);
    }
}

void printPostfixOp(PostfixOp op, uint64_t indent) {
    if (op.type == PostfixOp_Index) {
        printIndent(indent);
        ;

        printExpr(*(op.indexExpr), indent + 2);

        printIndent(indent);
        ;
    }
    else if (op.type == PostfixOp_Call) {
        if (op.callHasEmptyArgs) {
            printIndent(indent);
            ;
        }
        else {
            printIndent(indent);
            ;

            printArgExprList(op.callExprs, indent + 2);

            printIndent(indent);
            ;
        }
    }
    else if (op.type == PostfixOp_Dot) {
        printIndent(indent);
        ;
    }
    else if (op.type == PostfixOp_Arrow) {
        printIndent(indent);
        ;
    }
    else if (op.type == PostfixOp_Inc) {
        printIndent(indent);
        ;
    }
    else if (op.type == PostfixOp_Dec) {
        printIndent(indent);
        ;
    }
    else {
        
# 3753 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3753 "src/parser.c"
       "false"
# 3753 "src/parser.c" 3 4
       , "src/parser.c", 3753, __extension__ __PRETTY_FUNCTION__); }))
# 3753 "src/parser.c"
                    ;
    }
}

void printPostfixExpr(PostfixExpr expr, uint64_t indent) {
    if (expr.type == Postfix_Primary) {
        printPrimaryExpr(expr.primary, indent);
    }
    else if (expr.type == Postfix_InitializerList) {
        printInitializerList(expr.initializerList, indent);
    }
    else {
        
# 3765 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3765 "src/parser.c"
       "false"
# 3765 "src/parser.c" 3 4
       , "src/parser.c", 3765, __extension__ __PRETTY_FUNCTION__); }))
# 3765 "src/parser.c"
                    ;
    }

    for (SLNode *node = expr.postfixOps.head; node != 
# 3768 "src/parser.c" 3 4
   ((void *)0)
# 3768 "src/parser.c"
   ; node = node->next) {
        PostfixOp *op = slNode_getData(node);
        printPostfixOp(*op, indent);
    }
}

void printUnaryExprPrefix(UnaryExprPrefixType type, uint64_t indent) {
    printIndent(indent);
    switch (type) {
        case UnaryPrefix_And: {
            ;
            break;
        }
        case UnaryPrefix_Star: {
            ;
            break;
        }
        case UnaryPrefix_Plus: {
            ;
            break;
        }
        case UnaryPrefix_Minus: {
            ;
            break;
        }
        case UnaryPrefix_Tilde: {
            ;
            break;
        }
        case UnaryPrefix_Not: {
            ;
            break;
        }
        default: {
            
# 3802 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3802 "src/parser.c"
           "false"
# 3802 "src/parser.c" 3 4
           , "src/parser.c", 3802, __extension__ __PRETTY_FUNCTION__); }))
# 3802 "src/parser.c"
                        ;
            return;
        }
    }
}

void printUnaryExpr(UnaryExpr expr, uint64_t indent) {
    switch (expr.type) {
        case UnaryExpr_UnaryOp: {
            printUnaryExprPrefix(expr.unaryOpType, indent);
            printCastExpr(*(expr.unaryOpCast), indent + 2);
            break;
        }
        case UnaryExpr_Inc: {
            printIndent(indent);
            ;
            printUnaryExpr(*(expr.incOpExpr), indent + 2);
            break;
        }
        case UnaryExpr_Dec: {
            printIndent(indent);
            ;
            printUnaryExpr(*(expr.decOpExpr), indent + 2);
            break;
        }
        case UnaryExpr_SizeofExpr: {
            printIndent(indent);
            ;
            printUnaryExpr(*(expr.decOpExpr), indent + 2);
            break;
        }
        case UnaryExpr_SizeofType: {
            printIndent(indent);
            ;
            printTypeName(*(expr.sizeofTypeName), indent + 2);
            break;
        }
        case UnaryExpr_AlignofType: {
            printIndent(indent);
            ;
            printTypeName(*(expr.alignofTypeName), indent + 2);
            break;
        }
        case UnaryExpr_Base: {
            printPostfixExpr(expr.baseExpr, indent);
            break;
        }
        default: {
            
# 3850 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3850 "src/parser.c"
           "false"
# 3850 "src/parser.c" 3 4
           , "src/parser.c", 3850, __extension__ __PRETTY_FUNCTION__); }))
# 3850 "src/parser.c"
                        ;
            return;
        }
    }
}

void printCastExpr(CastExpr cast, uint64_t indent) {
    if (cast.type == CastExpr_Unary) {
        printUnaryExpr(cast.unary, indent);
    }
    else if (cast.type == CastExpr_Cast) {
        printIndent(indent);
        ;
        printTypeName(*(cast.castType), indent + 2);

        printIndent(indent);
        ;
        printCastExpr(*(cast.castExpr), indent + 2);
    }
    else {
        
# 3870 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3870 "src/parser.c"
       "false"
# 3870 "src/parser.c" 3 4
       , "src/parser.c", 3870, __extension__ __PRETTY_FUNCTION__); }))
# 3870 "src/parser.c"
                    ;
    }
}

void printMultiplicativeExpr(MultiplicativeExpr expr, uint64_t indent) {
    printCastExpr(expr.baseExpr, indent);
    for (SLNode *node = expr.postExprs.head; node != 
# 3876 "src/parser.c" 3 4
   ((void *)0)
# 3876 "src/parser.c"
   ; node = node->next) {
        MultiplicativePost *post = slNode_getData(node);
        printIndent(indent + 2);

        if (post->op == Multiplicative_Mul) {
            ;
        }
        else if (post->op == Multiplicative_Div) {
            ;
        }
        else if (post->op == Multiplicative_Mod) {
            ;
        }
        else {
            
# 3890 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3890 "src/parser.c"
           "false"
# 3890 "src/parser.c" 3 4
           , "src/parser.c", 3890, __extension__ __PRETTY_FUNCTION__); }))
# 3890 "src/parser.c"
                        ;
        }
        printCastExpr(post->expr, indent + 2);
    }
}




void printAdditiveExpr(AdditiveExpr expr, uint64_t indent) {
    printMultiplicativeExpr(expr.baseExpr, indent);
    for (SLNode *node = expr.postExprs.head; node != 
# 3901 "src/parser.c" 3 4
   ((void *)0)
# 3901 "src/parser.c"
   ; node = node->next) {
        AdditivePost *post = slNode_getData(node);
        printIndent(indent + 2);

        if (post->op == Additive_Add) {
            ;
        }
        else if (post->op == Additive_Sub) {
            ;
        }
        else {
            
# 3912 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3912 "src/parser.c"
           "false"
# 3912 "src/parser.c" 3 4
           , "src/parser.c", 3912, __extension__ __PRETTY_FUNCTION__); }))
# 3912 "src/parser.c"
                        ;
        }
        printMultiplicativeExpr(post->expr, indent + 2);
    }
}

void printShiftExpr(ShiftExpr expr, uint64_t indent) {
    printAdditiveExpr(expr.baseExpr, indent);
    for (SLNode *node = expr.postExprs.head; node != 
# 3920 "src/parser.c" 3 4
   ((void *)0)
# 3920 "src/parser.c"
   ; node = node->next) {
        ShiftPost *post = slNode_getData(node);
        if (node->next != 
# 3922 "src/parser.c" 3 4
                         ((void *)0)
# 3922 "src/parser.c"
                             ) {

            printIndent(indent + 2);

            if (post->op == Shift_Left) {
                ;
            }
            else if (post->op == Shift_Right) {
                ;
            }
            else {
                
# 3933 "src/parser.c" 3 4
               ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3933 "src/parser.c"
               "false"
# 3933 "src/parser.c" 3 4
               , "src/parser.c", 3933, __extension__ __PRETTY_FUNCTION__); }))
# 3933 "src/parser.c"
                            ;
            }
        }
        printAdditiveExpr(post->expr, indent + 2);
    }
}

void printRelationalExpr(RelationalExpr expr, uint64_t indent) {
    printShiftExpr(expr.baseExpr, indent);
    for (SLNode *node = expr.postExprs.head; node != 
# 3942 "src/parser.c" 3 4
   ((void *)0)
# 3942 "src/parser.c"
   ; node = node->next) {
        RelationalPost *post = slNode_getData(node);
        if (node->next != 
# 3944 "src/parser.c" 3 4
                         ((void *)0)
# 3944 "src/parser.c"
                             ) {

            printIndent(indent + 2);

            if (post->op == Relational_Lt) {
                ;
            }
            else if (post->op == Relational_Gt) {
                ;
            }
            else if (post->op == Relational_LEq) {
                ;
            }
            else if (post->op == Relational_GEq) {
                ;
            }
            else {
                
# 3961 "src/parser.c" 3 4
               ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3961 "src/parser.c"
               "false"
# 3961 "src/parser.c" 3 4
               , "src/parser.c", 3961, __extension__ __PRETTY_FUNCTION__); }))
# 3961 "src/parser.c"
                            ;
            }
        }
        printShiftExpr(post->expr, indent + 2);
    }
}

void printEqualityExpr(EqualityExpr expr, uint64_t indent) {
    printRelationalExpr(expr.baseExpr, indent);
    for (SLNode *node = expr.postExprs.head; node != 
# 3970 "src/parser.c" 3 4
   ((void *)0)
# 3970 "src/parser.c"
   ; node = node->next) {
        EqualityPost *post = slNode_getData(node);
        if (node->next != 
# 3972 "src/parser.c" 3 4
                         ((void *)0)
# 3972 "src/parser.c"
                             ) {

            printIndent(indent + 2);

            if (post->op == Equality_Eq) {
                ;
            }
            else if (post->op == Equality_NEq) {
                ;
            }
            else {
                
# 3983 "src/parser.c" 3 4
               ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 3983 "src/parser.c"
               "false"
# 3983 "src/parser.c" 3 4
               , "src/parser.c", 3983, __extension__ __PRETTY_FUNCTION__); }))
# 3983 "src/parser.c"
                            ;
            }
        }
        printRelationalExpr(post->expr, indent + 2);
    }
}

void printAndExpr(AndExpr expr, uint64_t indent) {
    for (SLNode *node = expr.list.head; node != 
# 3991 "src/parser.c" 3 4
   ((void *)0)
# 3991 "src/parser.c"
   ; node = node->next) {
        EqualityExpr *eqExpr = slNode_getData(node);
        printEqualityExpr(*eqExpr, indent);
        if (node->next != 
# 3994 "src/parser.c" 3 4
                         ((void *)0)
# 3994 "src/parser.c"
                             ) {

            printIndent(indent + 2);
            ;
        }
    }
}

void printExclusiveOrExpr(ExclusiveOrExpr expr, uint64_t indent) {
    for (SLNode *node = expr.list.head; node != 
# 4003 "src/parser.c" 3 4
   ((void *)0)
# 4003 "src/parser.c"
   ; node = node->next) {
        AndExpr *andExpr = slNode_getData(node);
        printAndExpr(*andExpr, indent);
        if (node->next != 
# 4006 "src/parser.c" 3 4
                         ((void *)0)
# 4006 "src/parser.c"
                             ) {

            printIndent(indent + 2);
            ;
        }
    }
}

void printInclusiveOrExpr(InclusiveOrExpr expr, uint64_t indent) {
    for (SLNode *node = expr.list.head; node != 
# 4015 "src/parser.c" 3 4
   ((void *)0)
# 4015 "src/parser.c"
   ; node = node->next) {
        ExclusiveOrExpr *orExpr = slNode_getData(node);
        printExclusiveOrExpr(*orExpr, indent);
        if (node->next != 
# 4018 "src/parser.c" 3 4
                         ((void *)0)
# 4018 "src/parser.c"
                             ) {

            printIndent(indent + 2);
            ;
        }
    }
}

void printLogicalAndExpr(LogicalAndExpr expr, uint64_t indent) {
    for (SLNode *node = expr.list.head; node != 
# 4027 "src/parser.c" 3 4
   ((void *)0)
# 4027 "src/parser.c"
   ; node = node->next) {
        InclusiveOrExpr *orExpr = slNode_getData(node);
        printInclusiveOrExpr(*orExpr, indent);
        if (node->next != 
# 4030 "src/parser.c" 3 4
                         ((void *)0)
# 4030 "src/parser.c"
                             ) {

            printIndent(indent + 2);
            ;
        }
    }
}

void printLogicalOrExpr(LogicalOrExpr orExpr, uint64_t indent) {
    for (SLNode *node = orExpr.list.head; node != 
# 4039 "src/parser.c" 3 4
   ((void *)0)
# 4039 "src/parser.c"
   ; node = node->next) {
        LogicalAndExpr *andExpr = slNode_getData(node);
        printLogicalAndExpr(*andExpr, indent);
        if (node->next != 
# 4042 "src/parser.c" 3 4
                         ((void *)0)
# 4042 "src/parser.c"
                             ) {

            printIndent(indent + 2);
            ;
        }
    }
}

void printConditionalExpr(ConditionalExpr expr, uint64_t indent) {
    printLogicalOrExpr(expr.beforeExpr, indent);

    if (expr.hasConditionalOp) {
        printIndent(indent);
        ;
        printExpr(*(expr.ifTrueExpr), indent + 2);
        printIndent(indent);
        ;
        printConditionalExpr(*(expr.ifFalseExpr), indent + 2);
    }
}

void printAssignOp(AssignOp op, uint64_t indent) {
    printIndent(indent);
    switch (op) {
        case Assign_Eq: {
            ;
            break;
        }
        case Assign_MulEq: {
            ;
            break;
        }
        case Assign_DivEq: {
            ;
            break;
        }
        case Assign_ModEq: {
            ;
            break;
        }
        case Assign_AddEq: {
            ;
            break;
        }
        case Assign_SubEq: {
            ;
            break;
        }
        case Assign_ShiftLeftEq: {
            ;
            break;
        }
        case Assign_ShiftRightEq: {
            ;
            break;
        }
        case Assign_AndEq: {
            ;
            break;
        }
        case Assign_XorEq: {
            ;
            break;
        }
        case Assign_OrEq: {
            ;
            break;
        }
        default: {
            
# 4111 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4111 "src/parser.c"
           "false"
# 4111 "src/parser.c" 3 4
           , "src/parser.c", 4111, __extension__ __PRETTY_FUNCTION__); }))
# 4111 "src/parser.c"
                        ;
            break;
        }
    }
}

void printAssignExpr(AssignExpr expr, uint64_t indent) {
    for (SLNode *node = expr.leftExprs.head; node != 
# 4118 "src/parser.c" 3 4
   ((void *)0)
# 4118 "src/parser.c"
   ; node = node->next) {
        AssignPrefix *prefix = slNode_getData(node);
        printUnaryExpr(prefix->leftExpr, indent);
        printAssignOp(prefix->op, indent + 2);
    }
    printConditionalExpr(expr.rightExpr, indent);
}

void printInnerExpr(InnerExpr expr, uint64_t indent) {
    if (expr.type == InnerExpr_Assign) {
        printAssignExpr(expr.assign, indent);
    }
    else if (expr.type == InnerExpr_CompoundStatement) {
        printCompoundStmt(*(expr.compoundStmt), indent);
    }
    else {
        
# 4134 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4134 "src/parser.c"
       "false"
# 4134 "src/parser.c" 3 4
       , "src/parser.c", 4134, __extension__ __PRETTY_FUNCTION__); }))
# 4134 "src/parser.c"
                    ;
    }
}

void printExpr(Expr expr, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = expr.list.head; node != 
# 4141 "src/parser.c" 3 4
   ((void *)0)
# 4141 "src/parser.c"
   ; node = node->next) {
        InnerExpr *inner = slNode_getData(node);
        printInnerExpr(*inner, indent + 2);
    }
}

void printParameterDeclaration(ParameterDeclaration decl, uint64_t indent) {
    printIndent(indent);
    ;

    printDeclarationSpecifierList(*(decl.declarationSpecifiers), indent + 2);

    if (decl.hasDeclarator) {
        printDeclarator(*(decl.declarator), indent + 2);
    }

    if (decl.hasAbstractDeclarator) {
        printAbstractDeclarator(*(decl.abstractDeclarator), indent + 2);
    }
}

void printParameterTypeList(ParameterTypeList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.paramDecls.head; node != 
# 4165 "src/parser.c" 3 4
   ((void *)0)
# 4165 "src/parser.c"
   ; node = node->next) {
        ParameterDeclaration *decl = slNode_getData(node);
        printParameterDeclaration(*decl, indent + 2);
    }
    if (list.hasEndingEllipsis) {
        printIndent(indent + 2);
        ;
    }
}

void printPostDirectAbstractDeclarator(PostDirectAbstractDeclarator post, uint64_t indent) {
    printIndent(indent);
    if (post.type == PostDirectAbstractDeclarator_Paren) {
        if (post.parenIsEmpty) {
            ;
        }
        else {
            ;

            printParameterTypeList(post.parenParamList, indent + 2);

            printIndent(indent);
            ;
        }
    }
    else if (post.type == PostDirectAbstractDeclarator_Bracket) {
        if (post.bracketIsEmpty) {
            ;
        }
        else if (post.bracketIsStar) {
            ;
        }
        else {
            if (post.bracketHasInitialStatic) {
                ;
            }

            printIndent(indent + 2);
            ;
            for (SLNode *node = post.bracketTypeQualifiers.head; node != 
# 4204 "src/parser.c" 3 4
           ((void *)0)
# 4204 "src/parser.c"
           ; node = node->next) {
                TypeQualifier *qualifier = slNode_getData(node);
                printTypeQualifier(*qualifier, indent + 2 + 2);
            }

            if (post.bracketHasMiddleStatic) {
                printIndent(indent + 2);
                ;
            }

            if (post.bracketHasAssignmentExpr) {
                printIndent(indent + 2);
                printAssignExpr(post.bracketAssignExpr, indent + 2);
            }
        }
    }
    else {
        
# 4221 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4221 "src/parser.c"
       "false"
# 4221 "src/parser.c" 3 4
       , "src/parser.c", 4221, __extension__ __PRETTY_FUNCTION__); }))
# 4221 "src/parser.c"
                    ;
    }
}

void printDirectAbstractDeclarator(DirectAbstractDeclarator direct, uint64_t indent) {
    printIndent(indent);
    ;

    if (direct.hasAbstractDeclarator) {
        printIndent(indent);
        ;

        printAbstractDeclarator(*(direct.abstractDeclarator), indent + 2);

        printIndent(indent);
        ;
    }

    for (SLNode *node = direct.postDirectAbstractDeclarators.head; node != 
# 4239 "src/parser.c" 3 4
   ((void *)0)
# 4239 "src/parser.c"
   ; node = node->next) {
        PostDirectAbstractDeclarator *post = slNode_getData(node);
        printPostDirectAbstractDeclarator(*post, indent + 2);
    }
}

void printPointer(Pointer pointer, uint64_t indent) {
    printIndent(indent);
    for (size_t i = 0; i < pointer.numPtrs; i++) {
        ;
    }

    ;

    for (SLNode *node = pointer.typeQualifiers.head; node != 
# 4253 "src/parser.c" 3 4
   ((void *)0)
# 4253 "src/parser.c"
   ; node = node->next) {
        TypeQualifier *qualifier = slNode_getData(node);
        printTypeQualifier(*qualifier, indent + 2);
    }

    if (pointer.hasPtr) {
        printPointer(*(pointer.pointer), indent + 2);
    }
}

void printAbstractDeclarator(AbstractDeclarator decl, uint64_t indent) {
    printIndent(indent);
    ;
    if (decl.hasPointer)
        printPointer(decl.pointer, indent + 2);

    if (decl.hasDirectAbstractDeclarator)
        printDirectAbstractDeclarator(decl.directAbstractDeclarator, indent + 2);
}

void printIdentifierList(IdentifierList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.list.head; node != 
# 4276 "src/parser.c" 3 4
   ((void *)0)
# 4276 "src/parser.c"
   ; node = node->next) {
        printIndent(indent + 2);
        String *str = slNode_getData(node);
        ;
        str = str;
    }
}

void printPostDirectDeclarator(PostDirectDeclarator post, uint64_t indent) {
    if (post.type == PostDirectDeclarator_Paren) {
        if (post.parenType == PostDirectDeclaratorParen_Empty) {
            printIndent(indent);
            ;
        }
        else if (post.parenType == PostDirectDeclaratorParen_IdentList) {
            printIndent(indent);
            ;

            printIdentifierList(post.parenIdentList, indent + 2);

            printIndent(indent);
            ;
        }
        else if (post.parenType == PostDirectDeclaratorParen_ParamTypelist) {
            printIndent(indent);
            ;

            printParameterTypeList(post.parenParamTypeList, indent + 2);

            printIndent(indent);
            ;
        }
        else {
            
# 4309 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4309 "src/parser.c"
           "false"
# 4309 "src/parser.c" 3 4
           , "src/parser.c", 4309, __extension__ __PRETTY_FUNCTION__); }))
# 4309 "src/parser.c"
                        ;
        }
    }
    else if (post.type == PostDirectDeclarator_Bracket) {
        printIndent(indent);
        if (post.bracketIsEmpty) {
            ;
        }
        else if (post.bracketIsStar) {
            ;
        }
        else {
            ;

            if (post.bracketHasInitialStatic) {
                printIndent(indent + 2);
                ;
            }

            printIndent(indent + 2);
            ;
            for (SLNode *node = post.bracketTypeQualifiers.head; node != 
# 4330 "src/parser.c" 3 4
           ((void *)0)
# 4330 "src/parser.c"
           ; node = node->next) {
                TypeQualifier *qualifier = slNode_getData(node);
                printTypeQualifier(*qualifier, indent + 2 + 2);
            }

            if (post.bracketHasMiddleStatic) {
                printIndent(indent + 2);
                ;
            }

            if (post.bracketHasAssignExpr) {
                printIndent(indent + 2);
                printAssignExpr(post.bracketAssignExpr, indent + 2);
            }
        }
    }
    else {
        
# 4347 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4347 "src/parser.c"
       "false"
# 4347 "src/parser.c" 3 4
       , "src/parser.c", 4347, __extension__ __PRETTY_FUNCTION__); }))
# 4347 "src/parser.c"
                    ;
    }
}

void printDirectDeclarator(DirectDeclarator direct, uint64_t indent) {
    printIndent(indent);
    if (direct.type == DirectDeclarator_Ident) {
        ;
    }
    else if (direct.type == DirectDeclarator_ParenDeclarator) {
        ;

        printDeclarator(*(direct.declarator), indent + 2);

        printIndent(indent);
        ;
    }
    else {
        
# 4365 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4365 "src/parser.c"
       "false"
# 4365 "src/parser.c" 3 4
       , "src/parser.c", 4365, __extension__ __PRETTY_FUNCTION__); }))
# 4365 "src/parser.c"
                    ;
    }

    printIndent(indent);
    ;
    for (SLNode *node = direct.postDirectDeclarators.head; node != 
# 4370 "src/parser.c" 3 4
   ((void *)0)
# 4370 "src/parser.c"
   ; node = node->next) {
        PostDirectDeclarator *post = slNode_getData(node);
        printPostDirectDeclarator(*post, indent + 2);
    }
}

void printDeclarator(Declarator decl, uint64_t indent) {
    printIndent(indent);
    ;
    if (decl.hasPointer) {
        printPointer(decl.pointer, indent + 2);
    }
    printDirectDeclarator(decl.directDeclarator, indent + 2);
}

void printTypeQualifier(TypeQualifier qual, uint64_t indent) {
    printIndent(indent);
    switch (qual) {
        case Qualifier_Const: {
            ;
            break;
        }
        case Qualifier_Restrict: {
            ;
            break;
        }
        case Qualifier_Volatile: {
            ;
            break;
        }
        case Qualifier_Atomic: {
            ;
            break;
        }
        default: {
            
# 4405 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4405 "src/parser.c"
           "false"
# 4405 "src/parser.c" 3 4
           , "src/parser.c", 4405, __extension__ __PRETTY_FUNCTION__); }))
# 4405 "src/parser.c"
                        ;
            break;
        }
    }
}

void printSpecifierQualifier(SpecifierQualifier specQual, uint64_t indent) {
    if (specQual.type == SpecifierQualifier_Specifier) {
        printTypeSpecifier(*(specQual.typeSpecifier), indent);
    }
    else if (specQual.type == SpecifierQualifier_Qualifier) {
        printTypeQualifier(specQual.typeQualifier, indent);
    }
    else {
        
# 4419 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4419 "src/parser.c"
       "false"
# 4419 "src/parser.c" 3 4
       , "src/parser.c", 4419, __extension__ __PRETTY_FUNCTION__); }))
# 4419 "src/parser.c"
                    ;
    }
}

void printSpecifierQualifierList(SpecifierQualifierList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.list.head; node != 
# 4426 "src/parser.c" 3 4
   ((void *)0)
# 4426 "src/parser.c"
   ; node = node->next) {
        SpecifierQualifier *spec = slNode_getData(node);
        printSpecifierQualifier(*spec, indent + 2);
    }
}

void printTypeName(TypeName name, uint64_t indent) {
    printIndent(indent);
    ;
    printSpecifierQualifierList(name.specifierQualifiers, indent + 2);
    if (name.hasAbstractDeclarator)
        printAbstractDeclarator(name.abstractDeclarator, indent + 2);
}

void printStructDeclarator(StructDeclarator decl, uint64_t indent) {
    printIndent(indent);
    ;
    if (decl.hasDeclarator)
        printDeclarator(decl.declarator, indent + 2);
    if (decl.hasConstExpr)
        printConditionalExpr(decl.constExpr, indent + 2);
}

void printStructDeclaratorList(StructDeclaratorList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.list.head; node != 
# 4452 "src/parser.c" 3 4
   ((void *)0)
# 4452 "src/parser.c"
   ; node = node->next) {
        StructDeclarator *decl = slNode_getData(node);
        printStructDeclarator(*decl, indent + 2);
    }
}

void printStaticAssertDeclaration(StaticAssertDeclaration staticAssert, uint64_t indent) {
    printIndent(indent);
    ;
    printConditionalExpr(staticAssert.constantExpr, indent + 2);
    printIndent(indent + 2);
    ;
    printIndent(indent + 2);
    ;
}

void printStructDeclaration(StructDeclaration decl, uint64_t indent) {
    if (decl.type == StructDeclaration_StaticAssert) {
        printStaticAssertDeclaration(decl.staticAssert, indent);
    }
    else if (decl.type == StructDeclaration_Normal) {
        printIndent(indent);
        ;
        printSpecifierQualifierList(decl.normalSpecifierQualifiers, indent + 2);
        if (decl.normalHasStructDeclaratorList) {
            printStructDeclaratorList(decl.normalStructDeclaratorList, indent + 2);
        }
    }
    else {
        
# 4481 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4481 "src/parser.c"
       "false"
# 4481 "src/parser.c" 3 4
       , "src/parser.c", 4481, __extension__ __PRETTY_FUNCTION__); }))
# 4481 "src/parser.c"
                    ;
    }
}

void printStructOrUnionSpecifier(StructOrUnionSpecifier structOrUnion, uint64_t indent) {
    printIndent(indent);
    if (structOrUnion.structOrUnion == StructOrUnion_Struct) {
        ;
    }
    else if (structOrUnion.structOrUnion == StructOrUnion_Union) {
        ;
    }
    else {
        
# 4494 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4494 "src/parser.c"
       "false"
# 4494 "src/parser.c" 3 4
       , "src/parser.c", 4494, __extension__ __PRETTY_FUNCTION__); }))
# 4494 "src/parser.c"
                    ;
    }

    if (structOrUnion.hasIdent) {
        ;
    }
    else {
        ;
    }

    printIndent(indent);
    if (!structOrUnion.hasStructDeclarationList) {
        ;
    }
    else {
        ;

        for (SLNode *node = structOrUnion.structDeclarations.head; node != 
# 4511 "src/parser.c" 3 4
       ((void *)0)
# 4511 "src/parser.c"
       ; node = node->next) {
            StructDeclaration *decl = slNode_getData(node);
            printStructDeclaration(*decl, indent + 2);
        }

        printIndent(indent);
        ;
    }
}

void printEnumerator(Enumerator enumer, uint64_t indent) {
    printIndent(indent);
    ;
    if (enumer.hasConstExpr) {
        ;
        printConditionalExpr(enumer.constantExpr, indent + 2);
    }
    else {
        ;
    }
}

void printEnumeratorList(EnumeratorList enumList, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = enumList.list.head; node != 
# 4536 "src/parser.c" 3 4
   ((void *)0)
# 4536 "src/parser.c"
   ; node = node->next) {
        Enumerator *enumerator = slNode_getData(node);
        printEnumerator(*enumerator, indent + 2);
    }
}

void printEnumSpecifier(EnumSpecifier enumSpec, uint64_t indent) {
    printIndent(indent);
    if (enumSpec.hasIdent)
        ;
    else
        ;

    if (enumSpec.hasEnumeratorList) {
        printEnumeratorList(enumSpec.enumeratorList, indent + 2);
    }
}

void printTypeSpecifier(TypeSpecifier type, uint64_t indent) {
    switch (type.type) {
        case TypeSpecifier_Void: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Char: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Short: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Int: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Long: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Float: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Double: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Signed: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Unsigned: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Bool: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Complex: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_Imaginary: {
            printIndent(indent);
            ;
            break;
        }
        case TypeSpecifier_AtomicType: {
            printIndent(indent);
            ;
            printTypeName(type.atomicName, indent + 2);
            break;
        }
        case TypeSpecifier_StructOrUnion: {
            printStructOrUnionSpecifier(type.structOrUnion, indent + 2);
            break;
        }
        case TypeSpecifier_Enum: {
            printEnumSpecifier(type.enumSpecifier, indent + 2);
            break;
        }
        case TypeSpecifier_TypedefName: {
            printIndent(indent);
            ;
            break;
        }
        default: {
            
# 4636 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4636 "src/parser.c"
           "false"
# 4636 "src/parser.c" 3 4
           , "src/parser.c", 4636, __extension__ __PRETTY_FUNCTION__); }))
# 4636 "src/parser.c"
                        ;
            break;
        }
    }
}

void printStorageClassSpecifier(StorageClassSpecifier storage, uint64_t indent) {
    printIndent(indent);
    switch (storage) {
        case StorageClass_Typedef: {
            ;
            break;
        }
        case StorageClass_Extern: {
            ;
            break;
        }
        case StorageClass_Static: {
            ;
            break;
        }
        case StorageClass_Thread_Local: {
            ;
            break;
        }
        case StorageClass_Auto: {
            ;
            break;
        }
        case StorageClass_Register: {
            ;
            break;
        }
        default: {
            
# 4670 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4670 "src/parser.c"
           "false"
# 4670 "src/parser.c" 3 4
           , "src/parser.c", 4670, __extension__ __PRETTY_FUNCTION__); }))
# 4670 "src/parser.c"
                        ;
            break;
        }
    }
}

void printFunctionSpecifier(FunctionSpecifier func, uint64_t indent) {
    printIndent(indent);
    if (func == FunctionSpecifier_Inline) {
        ;
    }
    else if (func == FunctionSpecifier_Noreturn) {
        ;
    }
    else {
        
# 4685 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4685 "src/parser.c"
       "false"
# 4685 "src/parser.c" 3 4
       , "src/parser.c", 4685, __extension__ __PRETTY_FUNCTION__); }))
# 4685 "src/parser.c"
                    ;
    }
}

void printAlignmentSpecifier(AlignmentSpecifier align, uint64_t indent) {
    printIndent(indent);
    if (align.type == AlignmentSpecifier_TypeName) {
        ;
        printTypeName(align.typeName, indent + 2);
    }
    else if (align.type == AlignmentSpecifier_Constant) {
        ;
        printConditionalExpr(align.constant, indent + 2);
    }
    else {
        
# 4700 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4700 "src/parser.c"
       "false"
# 4700 "src/parser.c" 3 4
       , "src/parser.c", 4700, __extension__ __PRETTY_FUNCTION__); }))
# 4700 "src/parser.c"
                    ;
    }
}

void printDeclarationSpecifier(DeclarationSpecifier decl, uint64_t indent) {
    switch (decl.type) {
        case DeclarationSpecifier_StorageClass: {
            printStorageClassSpecifier(decl.storageClass, indent);
            break;
        }
        case DeclarationSpecifier_Type: {
            printTypeSpecifier(decl.typeSpecifier, indent);
            break;
        }
        case DeclarationSpecifier_TypeQualifier: {
            printTypeQualifier(decl.typeQualifier, indent);
            break;
        }
        case DeclarationSpecifier_Func: {
            printFunctionSpecifier(decl.function, indent);
            break;
        }
        case DeclarationSpecifier_Alignment: {
            printAlignmentSpecifier(decl.alignment, indent);
            break;
        }
        default: {
            
# 4727 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4727 "src/parser.c"
           "false"
# 4727 "src/parser.c" 3 4
           , "src/parser.c", 4727, __extension__ __PRETTY_FUNCTION__); }))
# 4727 "src/parser.c"
                        ;
            break;
        }
    }
}

void printDeclarationSpecifierList(DeclarationSpecifierList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.list.head; node != 
# 4736 "src/parser.c" 3 4
   ((void *)0)
# 4736 "src/parser.c"
   ; node = node->next) {
        DeclarationSpecifier *decl = slNode_getData(node);
        printDeclarationSpecifier(*decl, indent + 2);
    }
}

void printInitDeclarator(InitDeclarator init, uint64_t indent) {
    printIndent(indent);
    ;
    printDeclarator(init.decl, indent + 2);
    if (init.hasInitializer)
        printInitializer(init.initializer, indent + 2);
}

void printInitDeclaratorList(InitDeclaratorList list, uint64_t indent) {
    printIndent(indent);
    ;
    for (SLNode *node = list.list.head; node != 
# 4753 "src/parser.c" 3 4
   ((void *)0)
# 4753 "src/parser.c"
   ; node = node->next) {
        InitDeclarator *init = slNode_getData(node);
        printInitDeclarator(*init, indent + 2);
    }
}

void printDeclaration(Declaration decl, uint64_t indent) {
    if (decl.type == Declaration_StaticAssert) {
        printStaticAssertDeclaration(decl.staticAssert, indent);
    }
    else if (decl.type == Declaration_Normal) {
        printIndent(indent);
        ;
        printDeclarationSpecifierList(decl.declSpecifiers, indent + 2);
        if (decl.hasInitDeclaratorList) {
            printInitDeclaratorList(decl.initDeclaratorList, indent + 2);
        }
    }
    else {
        
# 4772 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4772 "src/parser.c"
       "false"
# 4772 "src/parser.c" 3 4
       , "src/parser.c", 4772, __extension__ __PRETTY_FUNCTION__); }))
# 4772 "src/parser.c"
                    ;
    }
}

void printLabeledStatement(LabeledStatement label, uint64_t indent) {
    printIndent(indent);
    switch (label.type) {
        case LabeledStatement_Ident: {
            ;
            break;
        }
        case LabeledStatement_Case: {
            ;
            printConditionalExpr(label.caseConstExpr, indent + 2);
            break;
        }
        case LabeledStatement_Default: {
            ;
            break;
        }
        default: {
            
# 4793 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4793 "src/parser.c"
           "false"
# 4793 "src/parser.c" 3 4
           , "src/parser.c", 4793, __extension__ __PRETTY_FUNCTION__); }))
# 4793 "src/parser.c"
                        ;
            break;
        }
    }
}

void printSelectionStatement(SelectionStatement sel, uint64_t indent) {
    printIndent(indent);
    switch (sel.type) {
        case SelectionStatement_If: {
            ;
            printExpr(sel.ifExpr, indent + 2);
            printStatement(*(sel.ifTrueStmt), indent + 2);

            if (sel.ifHasElse) {
                printIndent(indent);
                ;
                printStatement(*(sel.ifFalseStmt), indent + 2);
            }

            break;
        }
        case SelectionStatement_Switch: {
            ;
            printExpr(sel.switchExpr, indent + 2);
            printStatement(*(sel.switchStmt), indent + 2);
            break;
        }
        default: {
            
# 4822 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4822 "src/parser.c"
           "false"
# 4822 "src/parser.c" 3 4
           , "src/parser.c", 4822, __extension__ __PRETTY_FUNCTION__); }))
# 4822 "src/parser.c"
                        ;
            break;
        }
    }
}

void printExpressionStatement(ExpressionStatement expr, uint64_t indent) {
    if (expr.isEmpty) {
        printIndent(indent);
        ;
    }
    else {
        printExpr(expr.expr, indent);
    }
}

void printIterationStatement(IterationStatement iter, uint64_t indent) {
    printIndent(indent);
    switch (iter.type) {
        case IterationStatement_While: {
            ;
            printExpr(iter.whileExpr, indent + 2);
            printStatement(*(iter.whileStmt), indent + 2);
            break;
        }
        case IterationStatement_DoWhile: {
            ;
            printStatement(*(iter.doStmt), indent + 2);
            printExpr(iter.doExpr, indent + 2);
            break;
        }
        case IterationStatement_For: {
            ;
            if (iter.forHasInitialDeclaration)
                printDeclaration(iter.forInitialDeclaration, indent + 2);
            else
                printExpressionStatement(iter.forInitialExprStmt, indent + 2);

            printExpressionStatement(iter.forInnerExprStmt, indent + 2);

            if (iter.forHasFinalExpr)
                printExpr(iter.forFinalExpr, indent + 2);

            printStatement(*(iter.forStmt), indent + 2);

            break;
        }
        default: {
            
# 4870 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4870 "src/parser.c"
           "false"
# 4870 "src/parser.c" 3 4
           , "src/parser.c", 4870, __extension__ __PRETTY_FUNCTION__); }))
# 4870 "src/parser.c"
                        ;
            break;
        }
    }
}

void printJumpStatement(JumpStatement jump, uint64_t indent) {
    printIndent(indent);
    switch (jump.type) {
        case JumpStatement_Goto: {
            ;
            break;
        }
        case JumpStatement_Continue: {
            ;
            break;
        }
        case JumpStatement_Break: {
            ;
            break;
        }
        case JumpStatement_Return: {
            ;

            if (jump.returnHasExpr) {
                printExpr(jump.returnExpr, indent + 2);
            }

            break;
        }
        default: {
            
# 4901 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4901 "src/parser.c"
           "false"
# 4901 "src/parser.c" 3 4
           , "src/parser.c", 4901, __extension__ __PRETTY_FUNCTION__); }))
# 4901 "src/parser.c"
                        ;
            break;
        }
    }
}

void printAsmStatement(AsmStatement stmt, uint64_t indent) {
    printIndent(indent);
    ;
}

void printStatement(Statement stmt, uint64_t indent) {
    switch (stmt.type) {
        case Statement_Labeled: {
            printLabeledStatement(stmt.labeled, indent);
            break;
        }
        case Statement_Compound: {
            printCompoundStmt(*(stmt.compound), indent);
            break;
        }
        case Statement_Expression: {
            printExpressionStatement(stmt.expression, indent);
            break;
        }
        case Statement_Selection: {
            printSelectionStatement(stmt.selection, indent);
            break;
        }
        case Statement_Iteration: {
            printIterationStatement(stmt.iteration, indent);
            break;
        }
        case Statement_Jump: {
            printJumpStatement(stmt.jump, indent);
            break;
        }
        case Statement_Asm: {
            printAsmStatement(stmt.assembly, indent);
            break;
        }
        default: {
            
# 4943 "src/parser.c" 3 4
           ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4943 "src/parser.c"
           "false"
# 4943 "src/parser.c" 3 4
           , "src/parser.c", 4943, __extension__ __PRETTY_FUNCTION__); }))
# 4943 "src/parser.c"
                        ;
            break;
        }
    }
}

void printBlockItem(BlockItem item, uint64_t indent) {
    if (item.type == BlockItem_Declaration) {
        printDeclaration(item.decl, indent);
    }
    else if (item.type == BlockItem_Statement) {
        printStatement(item.stmt, indent);
    }
    else {
        
# 4957 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 4957 "src/parser.c"
       "false"
# 4957 "src/parser.c" 3 4
       , "src/parser.c", 4957, __extension__ __PRETTY_FUNCTION__); }))
# 4957 "src/parser.c"
                    ;
    }
}

void printBlockItemList(BlockItemList list, uint64_t indent) {
    printIndent(indent);
    ;

    for (SLNode *node = list.list.head; node != 
# 4965 "src/parser.c" 3 4
   ((void *)0)
# 4965 "src/parser.c"
   ; node = node->next) {
        BlockItem *item = slNode_getData(node);
        printBlockItem(*item, indent + 2);
    }
}

void printCompoundStmt(CompoundStmt stmt, uint64_t indent) {
    if (stmt.isEmpty) {
        printIndent(indent);
        ;
    }
    else {
        printIndent(indent);
        ;

        printBlockItemList(stmt.blockItemList, indent + 2);

        printIndent(indent);
        ;
    }
}

void printFuncDef(FuncDef def, uint64_t indent) {
    printIndent(indent);
    ;

    uint64_t newIndent = indent + 2;
    printDeclarationSpecifierList(def.specifiers, newIndent);
    printDeclarator(def.declarator, newIndent);

    printIndent(newIndent);
    ;

    for (SLNode *node = def.declarations.head; node != 
# 4998 "src/parser.c" 3 4
   ((void *)0)
# 4998 "src/parser.c"
   ; node = node->next) {
        Declaration *decl = slNode_getData(node);
        printDeclaration(*decl, newIndent + 2);
    }

    printCompoundStmt(def.stmt, newIndent);
}

void printExternalDecl(ExternalDecl decl, uint64_t indent) {
    if (decl.type == ExternalDecl_FuncDef)
        printFuncDef(decl.func, indent);
    else if (decl.type == ExternalDecl_Decl)
        printDeclaration(decl.decl, indent);
    else {
        
# 5012 "src/parser.c" 3 4
       ((void) sizeof ((0) ? 1 : 0), __extension__ ({ if (0) ; else __assert_fail (
# 5012 "src/parser.c"
       "false"
# 5012 "src/parser.c" 3 4
       , "src/parser.c", 5012, __extension__ __PRETTY_FUNCTION__); }))
# 5012 "src/parser.c"
                    ;
    }
}

void printTranslationUnit(TranslationUnit translationUnit) {
    ;

    for (SLNode *node = translationUnit.externalDecls.head; node != 
# 5019 "src/parser.c" 3 4
   ((void *)0)
# 5019 "src/parser.c"
   ; node = node->next) {
        ExternalDecl *decl = slNode_getData(node);
        printExternalDecl(*decl, 2);
    }
}
